

# '비동기 처리' 를 위한 '콜백 패턴' 의 단점 

- '비동기 처리' 란? 
``` bash 

- '비동기 함수' 란 '비동기 함수' 안에서 '비동기로 동작하는 코드' 를 포함한 함수. (출처 : 모던 자바스크립트 p844)

- 예시 
	- 타이머 함수인 setTimeout, setInterval
	- HTTP 요청, 이벤트 핸들러

- 비동기 처리란 (by DJ)
	- '비동기로 동작하는 코드'의 '실행' '결과값'을, '어떻게 제어(컨트롤)' 하는 것.
	ex) 응답 결과를 -> 어디에 넣어서 -> 뭔가를 만들겠다. 
	- 'JS엔진의 제어범위를 벗어나서, 브라우저가 제어' 해서, 'Task Queue' 안에 쌓이고, 콜스택이 전부 비었을 때 실행되는 처리에 대해서 컨트롤 하는 것. 


'비동기로 동작하는 코드' 의 '처리 결과' 를 
	1) 외부로 반환(return) 하거나 
	2) 상위 스코프의 변수로 할당


(출처 : 모던 자바스크립트 p842)
```


<br>

### 비동기 방식으로 동작하는 코드의 처리값을 컨트롤 하기 어려운 이유 
``` BASH 
- '소스코드 상, 눈으로 볼 때의 실행순서'와, '실제 브라우저와 Event Loop 가 개입된 처리 순서'가 다르기 때문.
- 즉, 소스코드 상 가장 아래 코드가 실행되고 -> Task Queue 에 있는 task 가 실행 컨텍스트가 되어 실행되기 때문 (그렇기 때문에, Task queue 안에 쌓인 task로 실행컨텍스트만으로, 다시 로직을 짜야 한다. 그래서, 비동기 함수 내부에 콜백함수 제어문을 넣어야 한다. ⭐⭐⭐⭐⭐)
```


<br>


### 비동기 처리된 결과값을 콘솔로 찍고 싶은 경우

- 요약 
``` bash 
- 비동기로 처리되는 코드
	- xhr.onload 에 바인딩된 함수(이벤트 핸들러)

- 실행에 필요한 조건
	- [이벤트 캐치] 통신완료되면 -> 해당 이벤트 핸들러가 실행됨 
	- 브라우저가 이벤트 캐치 -> Task queue 로 이동 -> 대기 (call stack 비워질 때 까지) -> FIFO 순서로 실행

- 실제 실행 시점 
	- console.log 끝나고 실행됨. 

- 그러면, console.log 끝나고 처리되는 값에 어떻게 접근? 
	- '비동기 함수 외부' 로 접근하는 건 안 됨 -> 왜냐면, 실제 실행 시점이 모든 소스코드가 종료되고 난 다음이기 때문에 
	- '⭐비동기 함수 내부⭐' 로 접근할 수 밖에 없음 -> 따라서, 비동기 함수의 매개변수로, '원하는 기능을 갖고 있는 함수' 를 전달 (이렇게 '비동기 처리 결과값을 컨트롤 하기 위해, 비동기 함수에, 매개변수로써 전달되는 함수' 전달되는 함수를 '콜백함수', 라고 함. ⭐⭐⭐⭐⭐)

- 어떤 콜백함수를 전달? 
	- 비동기 처리 성공 및 실패시 실행될 콜백함수 2개를 전달
	- 그래서, 콜백함수로 console.log 를 전달하면 -> 비동기 처리된 결과값을 콘솔로 볼 수 있음! 
```


- 'onload 이벤트가 발생했을 때 실행되는 콜백함수(xhr.onload 이벤트 핸들러의 프로퍼티에 바인딩된 이벤트 핸들러)' 는 언제 실행되나? 원하는 곳에서 콜백함수의 처리값을 콘솔로 보려면? 여기에서 왜 undefined 가 찍히는가. ⭐⭐⭐⭐⭐⭐ 
``` js 
// [하고 싶은 것] '비동기 코드 실행 결과값' 을 console 로 찍고 싶음

// 그러면, 이 코드에서 '비동기 방식으로 동작하는 코드(Task Queue 안에서 대기하다가 실행되는 코드)' 는 무엇인가. 
	// xhr.send : 브라우저가 처리함. (Web api 에 내장된 XMLHttpsRequest 에 속한 프로퍼티)


const get = url => { 
	const xhr = new XMLHttpRequest( );
	xhr.open('GET' , url);     // 초기화
	xhr.send( );     // http 요청 전송 

	// 이벤트 핸들러를 '바인딩(등록)' : 'onload 이벤트 발생시', '실행될 함수(콜백함수, 이벤트 핸들러)' 를 등록 했다는 의미 ⭐⭐⭐ 
	xhr.onload = ( ) => { 
		if(xhr.status === 200) {
			// 서버 응답을 콘솔에 출력 
				return JSON.parse(xhr.response)
		} else {
			console.error(`${xhr.status} ${xhr.statusText}`)
		}
	}
		// 'onload 이벤트가 발생하면 -> 특정 함수를 실행시킬거야.' 라는건, 이미 짜여져 있음 -> so, 특별히 코드를 추가할 필요는 없음. -> so, 이미 그렇게 동작하게 됨.  
		// ⭐ 바인딩(등록) 되면, 'onload 이벤트 발생 여부' 및 'onload 발생시, 함수 실행(task queue 에 콜백함수 전달)' 역할을 누군가 해야 함 ⭐⭐⭐⭐⭐⭐  
			//  xhr.onload 는 XMLHttpRequest의 프로퍼티이고, XMLHttpRequest은 web api 가 제공하므로, js 엔진이 이 역할을 맡기에 무리 -> so, '이벤트 체크' 및 '이벤트 발생시 task queue 에 해당 콜백함수 전달' 은 '브라우저' 가 담당 
			// 따라서, onload 발생시 실행되는 콜백함수(onload 프로퍼티에 바인딩된 이벤트 핸들러) 는, task queue 에 대기하다가, js 엔진 콜스택이 전부 empty 가 된 후 실행된다. 

const response = get( 'http://jsonplaceholder.typicode.com/posts/1' )

console.log(response)  // undefined


/* get 함수 '평가 - 실행' 분석  
	1. 평가 
		- get 등록
		- response 등록 / 초기값 uninitialized
	
	2. 실행
		2.1 get 실행 컨텍스트 생성 
		2.2 get 함수 평가 
		2.3 get 함수 실행
		2.4 xhr 변수에 XMLHttpRequest 객체 할당 -> open -> send 실행 
		2.5 onload 실행 -> xhr.onload 이벤트 핸들러 '프로퍼티' 에 , '이벤트 핸들러' 를 '⭐바인딩⭐' 
			- 즉, 'onload 이벤트 발생시 실행될 함수를 지정함'
			- 즉, 
				- XMLHttpRequest 안에 있는 onload 프로퍼티는, 'onload 이벤트' 가 발생했을 때 실행되는 함수가 정의되는 곳 임. 
				- 현재, 해당 프로퍼티에, onload 이벤트 발생시, 실행될 행동을 정의해둔 것 임. 
				- 이걸, 'xhr.onload 이벤트 핸들러 프로퍼티' 에 '특정 이벤트 발생시 실행될 함수' 를 '바인딩' 했다고 말함 ⭐⭐⭐⭐⭐ 
		2.6 종료
	
	- 질문 
		- '이벤트 핸들러를 바인딩' 했다는 건, 해당 이벤트가 발생했을 때, 특정한 방식으로 처리해줄 코드를 기재했다는 건가? 👉 응. 그냥, 등록했다는 의미. 그래서, 실제로 'onload 이벤트를 캐치' 하려면, 실행 해줘야 해

	- 이 문제의 핵심 
		- 왜 response 를 찍으면, 서버에서 받은 값이 나오는게 아니라, undefined 가 찍히는가. 
			1) 'return 문을 포함하고 있는 함수' 는 언제 실행이 되는가 : onload 이벤트가 발생하고 -> 브라우저가 이 부분을 캐치해서 Task Queue 에 넘기고 -> 모든 실행컨텍스트가 pop 되고 -> 콜스택이 비워지면 -> 실행됨 
			2) 즉, 제일 끝에 있는 console.log 가 실행되고 난 후 -> 해당 이벤트 핸들러(콜백함수) 가 실행됨. ⭐⭐⭐ 
			3) 따라서, 서버에서 받아온 값(비동기로 처리되는 코드의 결과값) 은 담기지 않는다. 
*/

```


- 상위 스코프의 변수를 할당할 수 있을까? 
``` js 
let todos; 

const get = url => { 
	const xhr = new XMLHttpRequest( );
	xhr.open('GET' , url);     // 초기화
	xhr.send( );     // http 요청 전송 

	// 이벤트 핸들러를 '바인딩(등록)' : 'onload 이벤트 발생시', '실행될 함수(콜백함수, 이벤트 핸들러)' 를 등록 했다는 의미 ⭐⭐⭐ 
	xhr.onload = ( ) => { 
		if(xhr.status === 200) {
			// 서버 응답을 콘솔에 출력 
				todos =  JSON.parse(xhr.response)
		} else {
			console.error(`${xhr.status} ${xhr.statusText}`)
		}
	}

const response = get( 'http://jsonplaceholder.typicode.com/posts/1' )
console.log(todos)  // undefined


/* 	
- 이 문제의 핵심 
	- 왜 response 값은 왜 todos 할당이 되지 않는가. 
		- '할당의 실행' 역시, '해당 코드를 포함하는 실행컨텍스트인 onload 이벤트 핸들러의 실행시점' 에 달려 있다. 
		- onload 이벤트 핸들러는, 전역 소스코드가 모두 실행된 이후, 가장 늦게 실행되므로, todo 변수에는 아무것도 할당되지 않는다. 
*/
```


- 콜백함수를 통해 비동기 함수의 내부에 접근해서, 비동기 처리값을 컨트롤 하는 경우 
``` js 

const get = (url , successCallback, failureCallback) => { 
	const xhr = new XMLHttpRequest( );
	xhr.open('GET' , url);     // 초기화
	xhr.send( );     // http 요청 전송 

	// 이벤트 핸들러를 '바인딩(등록)' : 'onload 이벤트 발생시', '실행될 함수(콜백함수, 이벤트 핸들러)' 를 등록 했다는 의미 ⭐⭐⭐ 
	xhr.onload = ( ) => { 
		if(xhr.status === 200) {
			// 서버 응답을 콘솔에 출력 
				successCallback(JSON.parse(xhr.response))
		} else {
			failureCallback(xhr.status) 
		}
	}

get( 'http://jsonplaceholder.typicode.com/posts/1' , console.log, console.error)

// 시사점 
	// 비동기 함수의 매개변수로, 비동기 처리값을 컨트롤 하기 위한 함수, 를 전달 함! 이 함수를 콜백함수 라고 함. ⭐⭐⭐⭐⭐ 
```


<br>

### 콜백 헬(callback hell) 이 등장하는 경우 : 연쇄적 요청(Chained Requests) (이 순간을 실행 컨텍스트에 다시 쌓이는 경우로 이해!)
``` js
/* EX) 
'post id =1' 을 api 에 넘겨서 -> 해당 글을 작성한 user id 를 return 받는다. 
해당 user id 를 api 에 넘겨서 -> 해당 user 의 정보를 return 받는다. 

'POST ID = 1' -> API -> 'USER ID=1'  -> API -> 'USER INFO' 
👉 '연쇄적 요청' 이 되면, 첫 번째 비동기 처리의 return 이 2번째 비동기 처리의 input 이 된다. ⭐⭐⭐ 
👉 총 2번의 비동기 처리코드가 필요하다. 
*/


const get = (url, callback) => { 
	const xhr = new XMLHttpRequest( );
	xhr.open('GET' , url);     // 초기화
	xhr.send( );     // http 요청 전송 

	xhr.onload = ( ) => { 
		if(xhr.status === 200) {
			// 서버 응답을 콘솔에 출력 
				callback(JSON.parse(xhr.response))
		} else {
			failureCallback(xhr.status) 
		}
	}
}

const url = 'http://jsonplaceholder.typicode.com'

get( `${url}/posts/1` , ( {useId} ) => {
	// get 함수가 처음부터 실행이 된다. 
	// callback(JSON.parse(xhr.response)) 이 부분을 만났을 때 -> callback 함수 자리에, 여기에 있는 함수로 대체 된다. 
	// 그때, callback 의 매개변수로 들어온, JSON.parse(xhr.response) 값을 useId 에 넣는다. 
	// 그 다음, 다시 들어온 useId 로 요청을 보낸다. 
	// 보내고, 다시, get 함수정의부분이 실행이 되고 -> callback 함수 부분은, 매개변수로 정의한 콜백함수가 들어가고, 이때 매개변수는 userInfo 가 된다. 

	console.log(userId)
	get( `${url}/users/${userId}` , ( userInfo ) => {
		console.log(userInfo)
	}); 
});

```


<br>

### 콜백 패턴의 단점 : 에러 처리의 한계 ⭐⭐⭐⭐⭐ 

- try - catch 에 의해 에러 캐치가 되지 않는 이유 : 콜백함수의 실행시점 = 이미 `try - catch 구문이 종료된 시점`
``` js 
try { 
	setTimeout( ( ) => { throw new Error('Error!'); } , 1000 );
} catch (e) { 
	console.log('캐치한 에러' , e)
}

/* 
	( ) => { throw new Error('Error!'); } = 비동기 처리 코드 임. 
	( ) => { throw new Error('Error!'); } 의 실행 시점은, 콜스택이 전부다 empty 고 난 후 임. 
	'콜스택이 전부다 비었음' = try - catch 블록이 사라지고 없는 시점 을 의미 ⭐⭐⭐⭐⭐ 
	so, ( ) => { throw new Error('Error!'); } 이 실행되고 -> 에러가 발생해도 -> catch 자체를 못 함 (try - catch 블록은 실행 완료되고 사라졌기 때문)
```

<br>

- 그러면, 콜백패턴에서 error 를 캐치 하려면? : 에러를 탐지하고 싶은 코드의 스코프 안에, try-catch 문이 들어가야 한다. ⭐⭐⭐⭐⭐   
``` js  
// 1. 콜백함수 내부에서 try-catch 문 실행 
	setTimeout( ( ) => {
		try {
			throw new Error('Error!'); 			
		} catch (e) {
			console.log('error', e)	
		}
	}, 1000);
	// 이게 작동하는 이유는, throw new Error('Error!'); 이 콜백함수가 작동하는 시점에, try-catch 문이 있기 때문

// 2. promise 사용
👉 추가 공부 시작 
```


<br>

# 프로미스 

- 정리 
``` bash 
- promise 생성자 함수는, 비동기 처리를 수행할 resolve, reject 함수를 매개변수로 전달. 

- resolve, reject 함수가 하는 일 ⭐⭐⭐⭐⭐⭐ 
	- [전제조건] 비동기 처리가 성공했을 때 -> 1) resolve 가 실행되고 2) 실행결과값이 resolve 로 들어가게 짜야 한다. (실패했을 때는 reject) 이건, resolve 가 하는 일은 아님
	- 위의 2가지가 충족이 된다면 resolve, reject 는 다음과 같은 일을 한다. 
		- resolve 의 경우
			- 'promise 객체' 의 'status 값' 을 'fulfilled' 로 변경 
			- 'promise 객체' 의 'result 값' 을 '전달받은 매개변수' 로 변경

		- reject 의 경우 
			- 'promise 객체' 의 'status 값' 을 'rejected' 로 변경
			- 'promise 객체' 의 'result 값' 을 'Error' 로 변경 (⭐⭐⭐ 이 순간 에러 탐지가 됨 ⭐⭐⭐)



```



- 프로미스를 사용했을 때, 에러가 캐치되는 과정 분석 ⭐⭐⭐⭐⭐ 
``` js

const promiseGet = (url) => {
	
	// Promise 생성자 함수를 실행 -> 자동적으로 promise 객체가 생성됨 -> 그 결과를 return 하게 됨. 
		// 그러면 문제는, 'return 될 promise 객체'의 '어떤 프로퍼티'에, ;어떤 값'이, '언제 바인딩' 될 것 인가!
		// 그리고 결과적으로, return 될 promise 객체에는, 비동기 처리의 결과값이 담기게 된다. ⭐⭐⭐⭐⭐ 
	return new Promise ( (resolve, reject) => {  

	const xhr = new XMLHttpRequest( );
	xhr.open('GET' , url);     // 초기화
	xhr.send( );     // http 요청 전송 

	xhr.onload = ( ) => { 
	
		// 응답에 성공할 경우
			// resolve 가 응답에 성공할 경우 까지 체크하지는 않는다. 다만, resolve 를 사용하게 되면, 뒤이어서 then 메소드를 실행하게 된다는 점에서, 일반 콜백함수와는 다르다. (뭔가 기능이 들어가 있다.)
		if(xhr.status === 200) {
			
			// ⭐ '비동기 처리 완료된 값'은 'JSON.parse(xhr.response)' 이것임 
			// 해당 값을 resolve 의 인자로 넘김 
			// 그러면, 자동적으로, promise 객체의 특정 프로퍼티에 '바인딩' 됨 ⭐⭐⭐⭐⭐  
				resolve(JSON.parse(xhr.response))
		} else {
			// ⭐ '비동기 처리 완료된 값'은 'xhr.status' 이것임 
			// 해당 값을 reject 의 인자로 넘김 
			// 그러면, 자동적으로, promise 객체의 특정 프로퍼티에 '바인딩' 됨 ⭐⭐⭐⭐⭐ 
			reject(xhr.status) 
		}
	}
}

promiseGet( 'http://jsonplaceholder.typicode.com/posts/1' )


```


- 실패시 resolve , 성공시 reject 를 넣는다면? 
``` js 

const promiseGet = (url) => {
	return new Promise ( (resolve, reject) => {  

	const xhr = new XMLHttpRequest( );
	xhr.open('GET' , url);     // 초기화
	xhr.send( );     // http 요청 전송 

	xhr.onload = ( ) => { 
		if(xhr.status === 200) {
			// 서버 응답을 콘솔에 출력 
				reject(JSON.parse(xhr.response))
		} else {
			resolve(xhr.status) 
		}
	}
}

promiseGet( 'http://jsonplaceholder.typicode.com/posts/1' )
/*
[실행 분석]
	- 오류가 나지는 않음 
	- 다만, 성공/실패 상태 다음 실행되는 메서드가 달라짐.  
	
	- '실제로 비동기 처리 성공' 했음에도 -> reject 가 실행 -> 그에 따라서, .catch( ) 메서드가 실행됨. 
	- '실제로 비동기 처리 실패' 했음에도 -> resolve 가 실행 -> 그에 따라서, .then( )  메서드가 실행됨. 

[이를 통해 알 수 있는 것] 
1. resolve, reject 자체는 xhr.status 조건문 자체를 필터링 하지는 않는다. 그래서, 성공 status 에 reject 를 써도 돌아가기는 한다. 
2. 다만, reject 실행시 -> 연달아서, catch( ) 메소드가 실행된다. (resolve 는 then() 메서드) 이 부분은 '자동적으로 셋팅' 된 것 이다. ⭐⭐⭐ 따라서, 이 부분 때문에, 일반 콜백함수와 달라진다. ⭐⭐⭐ 
*/


```


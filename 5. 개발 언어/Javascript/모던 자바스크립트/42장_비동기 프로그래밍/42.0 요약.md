
## 동기 처리와 비동기 처리 

``` bash 
- 동기 처리 
	- 처리 방식
		- '현재 실행 중인 태스크' 가 '종료되지 않은 상황에서(진행중인 상황)'에서 -> '다음에 실행된 태스크' 가 '대기' 하게 해서 처리하는 방식
	- 장점
		- '소스 코드' 의 '실행 순서' 가 보장된다. (즉, 소스코드의 실행순서와 실제 실행순서가 동일하다. ) 
	- 단점
		- 블로킹(실행될 태스크들이 대기) 현상 발생

- 비동기 처리 
	- 처리 방식
		- '현재 실행 중인 태크스'가 '종료되지 않은 상황'에서 -> '그 다음 태스크' 를 '곧바로 실행' 한다. 
	- 장점
		- 블로킹(다음 태스크가 대기) 현상이 발생하지 않는다. 
	- 단점
		- '소스 코드 상의 기재 순서'와 '실제 실행 순서' 가 달라질 수 있다. ⭐⭐⭐  
		- 실행순서가 보장되지 않는다. 
			- ex) setTimeout 에서 0초를 delay 하더라도
				- 1) Web API 를 제공하는 브라우저 자체에서 0~4ms 미만은, 대기 시간을 4ms 로 강제하여 -> 실제로 0ms 로 설정했음에도, delay 시간은 4ms 가 되고 
				- 2) [실행 순서 관점] 실행 순서도, 1) 'JS 엔진의 콜 스택이 다 비워진 후' 2) Task Queue 에 태스크가 있으면 3) FIFO(First in First out) 으로 실행되기 때문에, -> 소스코드 상의 기재 순서와, 실제 실행 순서가 일치 하지 않는다. 
```


<br>


## 브라우저와 자바스크립트 엔진의 처리 방식은? 
``` bash 
- 브라우저의 구성 요소
	- '브라우저' 안에는 '자바스크립트 엔진', '렌더링 엔진', 'Web API' 등이 있다. 

- 브라우저의 특징 
	- '브라우저' 는 '멀티 스레드' 로 동작한다. 
		- 따라서, '자바스크립트 엔진' 이 동작하면서, 'Web API' 가 동작할 수 있다. (그래서, 'setTimeout 실행시, 타이머 함수(web api 제공)가 동작하면서, js 엔진이 그 다음 소스코드를 평가, 실행' 하는 비동기 처리가 가능한 것.)
		- 혹은, '자바스크립트 엔진' 이 동작하면서 '렌더링 엔진' 이 동작할 수 있다. (그래서, 'js 엔진이 서버에서 fetch 해오면서, 렌더링 엔진이 화면을 그리는' 비동기 처리가 가능한 것.  )

- JS 엔진의 특징
	- 자바스크립트 엔진은 '하나의 콜 스택' 이 있다. 
		- 이는, JS 엔진은 '싱글 스레드' 방식으로 동작한다. 는 의미다. 
		- 따라서, '한번에 하나의 태스크' 만 처리할 수 있고, '동시에, 2개 이상의 태스크는 처리 불가' 하다. 
		- 따라서, '실행 태스크 이외에 다른 태스크' 는 '기다려야 한다.' (블로킹 현상, 작업 중단 현상)

	- JS 엔진이 싱글 스레드 이므로, 모든 JS 소스 코드는 '동기처리가 되어야 할 것 같다.' 
	- 하지만, 실제로, '브라우저' 안에서 동작되는 것을 보면, '동시에 많은 태스트가 처리(비동기 처리)' 된다. ⭐⭐⭐ 
		- ex) 'HTTP 요청' 을 통해 -> 서버에서 데이터를 가져오면서 렌더링 한다. (출처 : 모던 자바스크립트 p812)
		- ex) '애니메이션 효과' 를 주면서 -> 이벤트를 처리 (출처 : 모던 자바스크립트 p812)


- 자바스크립트 동시성(concurrency) 의 원인 ⭐⭐⭐⭐⭐ 

👉 대체, 무엇 때문에, js 소스코드를 평가-실행하는 js엔진은 '싱글스레드' 인데, '비동기 효과'가 나는 걸까? ⭐⭐⭐⭐⭐ 
	
	1) 제어권 이동
		- '타이머 함수인 setTimeout, setInterval, HTTP 요청, 이벤트 핸들러' 는 '비동기 효과' 가 난다. 
		- 왜냐면, 'setTimeout, setInterval, HTTP 요청, 이벤트 핸들러' 는 'web api' 에서 제공하는 기능이므로 -> js 엔진은 해당 함수 실행 컨텍스트를 생성하고, 콜 스택에 push 한 다음, -> '해당 함수에 대한 제어권'을 'Web API' 에게 넘긴다. -> 그리고, JS 엔진은 싱글 스레드로써, 그 이후의 코드를 평가~실행 한다.  
	2) 이벤트 루프
		- Web API 가 해당 함수를 실행시키고 -> 이벤트 루프가 'Web API 와 JS 엔진 사이를 오가면서, 해당 함수가 다시 JS 엔진 콜스택에 들어갈 타이밍' 을 본다. 
		- 그 결과, 각 태스크는 대기 시간 없이, '비동기 처럼 처리' 된다. 
		- 이때, Task Queue 로 이동하고, Event loop 에 의해 옮겨지는 함수는, js 엔진의 콜 스택이 전부 비워져야 실행이 되므로, 멀티 스레드에서의 비동기처리와 비교했을 때, 실행되는 시점이 다를 수 있다. (즉, js 엔진의 스택이 전부 비워질 때 까지, 기다려야하는 추가 비용이 발생)


CF. 블로킹(blocking) = 작업 중단
CF. '타이머 함수인 setTimeout, setInterval', 'HTTP 요청', '이벤트 핸들러' 는 '비동기 처리 방식' 으로 동작함! ⭐⭐⭐⭐⭐(이제, 이걸 잘 다뤄야만 한다. ⭐⭐⭐) (출처 : 모던 자바스크립트 p812)
```


<br>


## 웹 어플리케이션에서, '비동기 처리' 의 핵심 요인은 ?
``` bash
- '타이머 함수인 setTimeout, setInterval', 'HTTP 요청', '이벤트 핸들러' 는 '비동기 처리 방식' 으로 동작함! ⭐⭐⭐⭐⭐(이제, 이걸 잘 다뤄야만 한다. ⭐⭐⭐) (출처 : 모던 자바스크립트 p812)

- 이것들의 공통점은, 해당 함수는,  js 엔진 안에, 내장 되어 있지 않다.⭐⭐⭐⭐⭐ 
	- ex) setTimeout 는 web api 에 의해 제공된다는 것. 
	- ex) HTTP 요청은 fetch(web api) 에 의해 제공되고 
	- ex) 이벤트 핸들러는 DOM(web api) 에 의해 제공됨. 

- js 엔진 내부에 내장 되어 있지 않으므로 -> 제어권을, '해당 함수를 제어할 수 있는 요소 ex) web api'에 넘기고 -> js 엔진은 다시 소스코드를 평가-실행 한다. -> 그리고 js 엔진은 동기처리 흐름 안에서, '이벤트 루프' 의 도움을 받아, 다른 요소가 제어한 함수를 실행한다.

- 그 결과, 비동기 효과가 난다.
```


<br>

## setTimeout 이 작동하는 과정 

``` js 
function foo( ) {
	console.log("foo);

}

- 출처 : 모던 자바스크립트 p814
```


``` js 
// 1. 전역 코드 평가 

// 2. 전역 코드 실행 
	// 2.1 제어권이 setTimeout 함수 내부로 이동 
		// 2.1.1  2개의 실행 컨텍스트 생성 : 1) setTimeout 자체의 실행 컨텍스트 2) web api 를 호스트로 하는 타이머 함수
		// 2.1.2  setTimeout 실행 컨텍스트 call stack 으로 이동 -> 실행 
		// 2.1.3   JS 엔진은 'web api 를 호스트로 하는 타이머 함수' 를 내장하고 있지 않으므로 -> 타이머 함수 제어권을 web api 에게 넘김 ⭐⭐⭐⭐⭐ 
		// 👉 그 이후는 '브라우저가 멀티 스레드 이므로, 병행 처리' 됨! ⭐⭐⭐ 
			//  1) JS 엔진은 setTimeout 함수 를 스택에서 pop 하고 -> 다음 줄로 이동 
			//  2) ⭐동시에(병행 처리)⭐, 브라우저가⭐, 타이머 함수 제어권이 있는 web api 는, 시간 대기 -> 콜백 함수를 task queue 에 등록 -> js 엔진의 콜스택이 비어 있으면, 이벤트 루프가 해당 task 를 js 엔진 콜스택으로 이동~! 

	// 2.2 [JS 엔진] bar 함수 실행 컨텍스트 생성 -> 콜스택 push -> 실행 -> pop 
	// 2.3 [JS 엔진] 전역 실행 컨텍스트 생성 -> 콜스택에 push -> 실행 -> pop -> 콜스택 비어있게 됨 ⭐⭐ 
	// 2.4 [브라우저의 이벤트 루프] task queue 에 대기하고 있는 task 를 FIFO 순서로, CALL STACK 에 PUSH -> 실행 컨텍스트 생성 되어 PUSH 되므로 실행 -> 실행 완료 후 POP -> 다시 CALL STACK 이 비어있게 됨 -> 종료


👉 결국, '자바스크립트 엔진' 과 '브라우저' 가 '협력' 하여, '비동기 함수' 인 'setTimeout' 을 '비동기 처리' 한다. 
👉 다른 비동기 처리들도, 익혀보자. 
```










## 렌더링 과정 요약
``` bash
- [요약] 서버 요청 -> 서버 응답 -> 인코딩 -> HTML 파싱 및 DOM 생성 -> CSS 파싱 및 CSSOM 생성, js 파싱 및 AST 생성 -> 렌더 트리 생성 -> layout -> paint 

- [부연 설명] 
	- HTML 파싱 과정에서, script 태그를 만나면, 해당 js 파일을 서버에 요청하고 -> 응답을 받게 되면, 제어권이 js 엔진으로 넘어간다 -> js 엔진이 js 파싱을 마친후, 다시 브라우저 엔진에게 제어권이 복구되어 DOM 생성을 이어나간다. 
```

![](https://i.imgur.com/J8iIyHb.png)


(출처 : 모던 자바스크립트 p660)
(그림 출처 : 모던 자바스크립트 p669)


<br>


## '서버 요청'
``` bash
- 주소창에 URI 입력
	- URI 는 protocol + host(domain) + port + path + query + fragment  로 구성됨 | 📛query + fragment 이게 약함  
	- 해당 path 는 '서버의 루트 폴더' 를 기준으로 한다.
	- https://busiman.shop/assets/data.json 을 기재하면 -> 해당 폴더에 있는 'data.json' 정적 파일을 요청 하게 됨. ⭐

- 정적/동적 데이터 요청은 ajax 와 REST API 학습하고 보충 ✅ (출처 : 모던 자바스크립트 662p)
```

👉 ajax (모던 자바스크립트 43장), rest api(모던 자바스크립트 44장) 공부 ⭐ 



<br>


##  '서버 응답'
``` bash
- 서버로 부터, '바이트 코드'로 응답받는다. 

- html 파일만 요청했는데, js, css, 이미지 파일 등이 응답되는 현상의 원인? ⭐⭐⭐⭐⭐ 
	- HTML 파일을 먼저 받고 DOM 생성하는 과정(인코딩 -> 토큰 -> 노드 -> DOM) 에서, css 로드하는 link 태그, 이미지 파일 로드하는 img 태그, js 로드하는 script 태그를 만나면 -> DOM 생성을 멈추고, 해당 파일을 서버에게 요청하고 응답 받기 때문임. 

```


<br>

## HTML 파싱과 DOM 생성 
``` bash
- DOM 이란
	- Document : html 문서 
	- Object : html 문서에서, 문법적 의미를 갖는 최소 단위인 토큰을 생성하고, 객체로 표현. 
	- Model : 해당 객체의 '중첩 관계(부모 자식 관계)' 를 '트리 자료구조' 로 변환하여 모델링

- 전체 과정
	- 인코딩 (바이트 코드 -> 문자열 변환) -> '토큰' 생성 -> '노드' 생성 -> 'DOM' 생성

- 인코딩 
	- 서버로 부터 01010101 의 바이트 코드로 응답을 받음 
	- utf-8 같은 인코딩 방식으로 '문자열' 로 변환 

- '토큰' 생성
	- 문자열 중, '미리 정해놓은 규칙을 따르는 문자열' 이 있다면, 조건식을 활용하여, return 하여 '토큰' 의 값으로 넣는다. (피그마 공부 자료 : https://bit.ly/3H9xmYd)

- '노드' 생성
	- ex) 토큰 객체 중, 'startTag' 이름을 가진 것을, 노드로 만든다. 
	- 노드는 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드로 구분된다. 

- 'DOM' 생성
	- 노드 간 '중첩관계' 를 반영하여 '트리 자료구조' 로 변환하여 'DOM' 생성한다. 

```


<br>


## CSS 파싱 및 CSSOM 생성
``` bash 
- 전체 과정 
	- css 파일은 DOM 생성과정에서 link 태그를 만났을 때, css 를 다운받게 됨. 
	- HTML 의 DOM 생성과 동일한 과정으로 CSSOM 을 생성
	- CSSOM 생성이 종료되면 -> HTML 파싱이 중단된 지점부터, 다시 DOM 생성한다. 
```


<br>

## js 파싱 및 AST 생성
``` bash
- 전체 과정 
	- js 파일은 DOM 생성과정에서 script 태그를 만나면, DOM 생성 중단 하고, javascript 를 다운받게 됨. 
	- '브라우저 엔진'는 서버 응답이 완료되면, '자바스크립트 엔진' 에 '제어권' 을 넘긴다. -> 'JS 엔진' 이 '파싱과 실행' 을 담당 -> 이후 다시, 브라우저 엔진에게 제어권을 넘겨, 중단지점부터 다시 DOM 생성
	- 토크나이징 -> 파싱 -> 바이트 코드 생성 -> 실행 

- js 다운받기 
	- HTML 소스코드의 동기적 실행의 특성상, 블로킹 현상을 대비하기 위해, 보통, body 태그의 제일 아랫부분에 script 태그 설정.

- 토크나이징 
	- 'js 소스코드' 에서 '미리 정해둔 규칙대로 적혀진 부분' 을 '토큰' 으로 만든다. 
	- '어휘 분석'

- 파싱 
	- '토큰' 에서 'tree 구조' 인 'AST(Abstract syntax tree, 추상적 구문 트리)' 를 만든다. 
	- 추측컨대 1) 토큰 중 특정 키워드가 있는 것을 '노드' 로 만들고 2) '부자 관계' 반영하여 3) '객체' 로 표현 
	- 여기까지, '평가' 단계

- 바이트 코드
	- '실행' 단계 
	- 인터프리터가 실행할 수 있는 코드 

- 실행
	- 기계가 바이트코드를 이해하여 실행한다.
	- DOM API 를 이용하여, JS 가 DOM, CSSOM 변경할 수 있고 -> 그에 따라, '리플로우 및 리페인트'가 일어난다. 
```


<br>

## 렌더 트리 생성 
``` bash
- 원칙
	- DOM 과 CSSOM 을 결합하여 만든다. 
	- 브라우저에 '렌더링 되는 노드만!'으로 구성된다. ⭐⭐⭐ 


- 레이아웃 계산(reflow) 및 paint(repaint) 가 재차 실행 되는 경우 (#📛📛) 
	- 브라우저 '렌더링 단계별' 영향을 받는 경우 (출처 : 모던 자바스크립트 p669 에서 그림 38-9 에서, 각 요소별로, 다시 계산해야 하는 경우)
	
	- reflow : layout(요소의 크기 및 위치) 다시 계산
	- repaint : 재렌더링 모두를 의미. reflow 가 없어도, repaint 가 일어날 수 있음. 
	- JS 실행 중 DOM API 조작이 있을 경우 -> DOM, CSSOM 변경에 따라서, 렌더트리가 다시 생성된다. -> 따라서, 기존의 layout 계산을 폐기하고, 새롭게 계산하게 된다. 
	- 브라우저 창에 의한 뷰포트(view port) 크기 변경 
	- HTML 요소의 레이아웃 스타일 변경 
	
	- 이슈
		- DOM API 조작을 통해, 렌더링이 다시 되는 것만! repaint 로 봐야 하는가! -> NO! DOM 조작에만 국한되지 않음. 


- 브라우저 렌더링 최적화 방안
	- 리플로우 및 리페인트가 일어나지 않도록! width/height, marign, padding, border, display, position, top/right/bottom/left 의 사용 지양 
	- 참고 : https://bit.ly/47qInyX
```

![](https://i.imgur.com/zlbDs8C.png)


<br>

## layout 
``` bash 
- html 요소의 크기와 위치를 계산
- layout 다시 계산하는 것을 reflow 라고 함
```


<br>

## paint
``` bash
- 브라우저 렌더링 엔진이 paint 하기 시작
```


<br>


## 브라우저 렌더링이 반복되는 경우 
``` bash
- '자바스크립트 노드' 가 추가 또는 삭제 되는 경우 (DOM API 사용하는 경우)
- '브라우저 창의 리사이징' -> 뷰포트 크기 변경 -> layout 계산을 다시 하게 됨. 
- HTML 요소의 layout(요소의 위치 또는 크기) (width/height, margin, padding, border, display, position, top/right/bottom/left) 등 스타일 변경

CF. DOM API 사용과 리플로우 & 리페인트 (출처 : 모던 자바스크립트 P672)
	- DOM API 사용 -> DOM, CSSOM 변경 -> 렌더트리 변경 -> 레이아웃 변경 -> 다시 paint
	- reflow : '레이아웃'을 다시 계산하는 것
	- repaint
		- 재결합된 '렌더트리' 를 기반으로, 다시 페인트 하는 것.
		- 레이아웃 변경이 없는 경우, reflow 없이 repaint 가 일어날 수 있음
```



<br>


## 이슈 

### 1) 브라우저의 동기적 실행과 대안 
``` bash
1. 'body 요소의 가장 아래' 에 js 위치
- 브라우저는 순차적으로 소스코드를 파싱 -> DOM 생성 중 블로킹 된다. 
- 따라서, 'body 요소의 가장 아래' 에 js 위치 -> DOM 생성 블로킹 방지 가능 

2. script 태그의 async/defer 어트리뷰트 
```

<br>

### 2) 브라우저 렌더링 최적화 방안
``` bash
- 리플로우 및 리페인트가 일어나지 않도록! width/height, marign, padding, border, display, position, top/right/bottom/left 의 사용 지양
```

- 관련 면접 질문 [[모음 1#2. 렌더링 최적화]]



<br>

## 보완할 부분 
1. ajax (모던 자바스크립트 43장), rest api(모던 자바스크립트 44장) 공부 
	- 비동기 프로그래밍 요약 ([[42.0 비동기 프로그래밍 요약]])
2. 브라우저 최적화 방안을 실제 프로젝트로 보완해보자 ⭐⭐⭐ 


<br>



---

- 출처 
	- 모던 자바스크립트 38장 브라우저 렌더링 과정
	- [[240108_140010_브라우저의 렌더링 과정]]
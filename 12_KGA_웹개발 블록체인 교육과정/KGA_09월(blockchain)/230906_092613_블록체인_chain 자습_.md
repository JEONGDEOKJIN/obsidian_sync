


# [Do]
### 코테
[[230906 코테풀이]]

```
잠깐, 지금 맹목적으로 풀고 있다는 생각이 든다.
0단계는 어떤 메소드를 익히는 것 같은데, 내가 그 쓰는 방법에서 부족한 부분이 분명 있을 거야 
그걸, 표로 만들어서 내 단점을 적어놓고, 그 부분을 또한 보완해야 할거 같은데
```



| 구분                | 설명 | 비고                                                                                                             |
| ------------------- | ---- | ---------------------------------------------------------------------------------------------------------------- |
| [[230905 코테 풀이]]                    |      |                                                                                                                  |
| [[230906 코테풀이]] |      | 🔵 문자열 자르는 부분이 약함 <br> 📛 함수가 반환되어서, 결과를 만들어낸다는 점 <br> ✅ 너무 맹목적으로 하지 말자 |



### kga 수업 및 수업 내용 복습 
- 어제 주석 못 달았던 chain 파트 복습중 
[[230905_084512_코테_타입스크립트_블록체인]]

- 주석을 달고 -> 반드시 '흐름 요약' 을 한눈에 할 수 있어야 한다.
	- 반드시 '요약본' 있어야 함 ⭐⭐⭐⭐⭐ 
	- 그건, 나를 위해 
	- '흐름' 은 어떤 방식으로? 
	- 절차? UML? 
	- 그 다음 코드는 '자세한 분석' 이니깐! 


- [📛📛📛 에러] 파일 '경로' 때문에, tsc 설치가 안 되고, 폴더 이름이 계속 typescript 로 잡혔음 | 📛📛📛 버그 리포트, 시간이 오랜 에러에 등록! 

![](https://i.imgur.com/rdRXbZB.png)

- 이 부분이 현재는 typescript 인데, 'typescript&blockchain' 으로 변경했음에도, 인식하지 못 했어... 
![](https://i.imgur.com/AqsOmnw.png)


- [질문📛📛📛📛📛📛📛📛] jest.config.ts 파일은 직접 만들어야 하는거 맞지? npm i -D @types/jest jest 를 한다고 해서 자동적으로 생기는게 아니라!?  

``` sh
# jest 설치 
npm i -D @types/jest jest

# jest.config.ts
> 이건 직접 ts 파일 만들어야 함 
> 맞지❓❓ 
```
![](https://i.imgur.com/mMdCB1f.png)



- 옵시디언에서 노션같은 효율적인 관리 view 를 구현하거나, 노션에서 export 하는 걸 더 쉽게 하거나 음 



















# [회고]


### 준비 stance 
```
나는, 어떤 부분에서, 확실하게 기여할 수 있을까? 내가 부족한 부분은 어떻게 보완해야 할까? 라는 질문 
```

<br>

### 어떻게 하면, 흐름 파악을, 좀 더, 잘 할 수 있을까? 
```
뭔가 어떤 모듈 덩어리가 있다. 
이게 어떤 일을 하는 건지 빠르게 파악하고 싶으면, 어떻게 해야 할까. 
음. 
절차적 분석? 그거랑, dfd? 그걸 적용해봐야 할까? 
```



### 내가 지금 이 부분 파악하는데 시간이 오래 걸림 | 함수 의 매개변수로 전달한게, | 다시 복습할 필요가 있음 ⭐⭐⭐⭐⭐ | 이것으로 알 수 있는 나의 약점은 1) 콜백함수 2) find 메서드 | 확실히 알게 된 건, 1) '한 단계씩, 한 단계씩 컴퓨터 입장에서, 무엇을 가리키는지를, 한 단계를 읽어나가야 한다는 것' 2) 확정된 것, 아직 확정되지 않은 것을 구분해서 읽어나가면 편하다 
![](https://i.imgur.com/ln9PVwf.png)
![](https://i.imgur.com/apiYqYZ.png)


(지금 나의 상태를 과대 평가하지 말자. 받아들이자. 그리고, 내가 기여할 수 있는 부분을 반드시 찾아서 갈고 닦아야 한다.)

(자, 이런 유형의 코드 분명 존재한다. )

1차 함수가 있고 
1차 함수의 매개변수로 들어온게, 
2차 함수의 매개변수인 콜백함수의 결과값으로 들어가고, 


- 아 이런게 절차적분석인가. 어쩔 수가 없나. 

 
- getBlockByHeight 실행
``` ts
// getBlockByHeight(1) 함수 호출 
console.log(newChain.getBlockByHeight(1))   // block 들 중에서, 높이가 1 인 값, 을 가져오기
> 그 다음에 어떻게 실행되는지 따라가보기
```

- getBlockByHeight 실행 흐름 
``` ts
    getBlockByHeight(height : number){
        return this.getBlock( (block : Block) => block.height === height )
    }

1. height 매개변수로 '숫자 타입' 인 1 이 들어온다. 

자, 그 다음에 어떤게 실행되나? 
이 부분에서, 급하다고, 혹은 내가 잘한다고, 혹은 잘해야 한다는 마음에서, 슉, 넘겨 짚지 말것. ⭐⭐⭐⭐⭐
하나씩, 가리키는 것을 '구체적으로' 따라가면 된다. 

2. 그러면, this 를 만나고 -> this 는 '현재, Chain 클래스' 안에 있으므로 -> 'Chain 클래스의 인스턴스' 를 의미한다. 

3. 그러면, Chain 클래스 인스턴스의 getBlock 메소드를 찾아가게 된다. (가서 실행하려고) (getBlock 이 있다고 치고! 컴퓨터가 되었다고 생각하고, 하나씩 해보자.)
	그런데! 그냥 슉 가는게 아니라, '매개변수가 존재하므로, 매개변수도 같이 가져가야 한다.'
	매개변수는 'block 이 들어오면, block 의 높이, 와 현재 매개변수인 1이 같은지 여부' 그 자체이다. (여기에서 중요한 건, ⭐컴퓨터의 입장⭐이 되어서, 이게 값이 확정되지 않았다고 해도, 미확정인 채로, 읽어나간다.)

4. 이제, '매개변수를 들고',  getBlock에게 가서, 실행 시킨다. 그럼, 구체적으로 어떤 일이 벌어지나. 

5. 곧바로 실행하는 관점이라면!! (왜냐면, 지금 height 에 1을 넣은 상황이니) this 를 먼저 해석하게 된다. 여기에서 this 는 'Chain 의 인스턴스' 를 의미한다.

6. this.chain 은 'block 으로 된 배열' 을 의미한다. 

7. this.chain.find 는 " 'block 으로 된 배열' 은 1) 각 요소(block)에 대해서 3) callbackFn 이 만족되면 4) return 한다.  " 라는 의미가 된다. 

8. 여기에서 callbackFn 이 어려울 수 있는데, 그냥, 'callbackFn' 자리에 '(block : Block) => block.height === 1' 을 넣으면 된다. (⭐⭐⭐⭐⭐ 이렇게 자리 바꿔넣기 하면 된다. ⭐⭐⭐⭐⭐ )

(여기서 헤맸던 건, 어떻게 매개변수로 함수가 들어갈 수 있는가! 라는 점 이었는데, 
chain 이라는 배열 요소 각각을 map 처럼 집어넣는다, 라는 관점으로 접근하니까, 풀렸다 ⭐⭐⭐ 어떻게 보면, 나는 각 메소드를 아직 편하게 이해하지 못 하는 것 같다. )

9. 그러면, chain 에 있는 블록이 하나씩 들어가서 -> 조건이 맞는지 보고 -> 맞으면 return 된다. 
```


- 이것을 요약하면 
```bash
[실행순서]
	1. getBlockByHeight 에 매개변수 1 이 들어감 
	2. getBlockByHeight 함수에서 this 가 확정되고 -> 매개변수가 확정된 상황에서 getBlock 이 호출 
	3. getBlock 에서 this 확정 -> 'chain 이 배열'이라는 게 확정 -> 'find 메소드' 를 만나서 배열을 하나씩 콜백함수로 던져서 '콜백함수' 를 실행

이렇게 될 텐데, 
1) 내가 해석이 약했던 부분은 'find 메소드' 를 해석하는 부분 
2) 콜백함수를 해석하는 부분 
```






### 이 부분 문법을 잘 모르겠음 👇👇 | '배열 타입 표기법' 에 대해서 잘 몰랐던 거 였음. | 몰랐던 부분 이것도 회고 기록 가능 🙆‍♂️🙆‍♂️  
```
    private chain : Block[] = [GENESIS];
```

- 알게 된 것 

``` ts


import { Block } from "@core/block/block";
import { GENESIS } from "@core/config";
import { Failable } from "@core/interface/failable.interface";
    /*  [궁금증] 
        Failable 이 현재, 어떤 기능을 하는지 잘 이해 안 됨
    */


class Chain {

    private chain : Block[] = [GENESIS]
    /* [해석]
        ' : Block' = Block 클래스를 타입으로 사용한다 = Block 클래스의 인스턴스가 chain의 타입으로 온다
        ': Block[]' = 그 인스턴스 타입들이 배열에 담긴다. 

        즉, chain 은 1) 'Block 클래스의 인스턴스 or 인스턴스들' 이 담긴 2) '배열' 이다. 
        이것을 가능하게 하는 문법은 Block[] 이것임 | ✅ 몰랐었음!! 

    */



}

export default Chain
```

<br>

### 이 문법을 보는데, callbackFn 이 함수가, 정의되어 있어야 하는거 아닌가? 라는 착각을 했음 😥 | 아직 부족하다는 증거 

```
    // 블록을 조회하는 메서드 
    getBlock(callbackFn : (block : Block) => boolean ){
        const findBlock = this.chain.find(callbackFn);
        
        // 블록이 없으면 -> 블록 없음! 이라고 내보냄! 
        if(!findBlock) throw new Error("찾은 블록이 없음!")
        
        // 블록이 있으면! findBlock 을 던짐
        return findBlock
    }
```



### 다시, 초심으로 공부해야 한다. 한단계씩, 포인트는 '내가, 컴퓨터의 관점에서, 하나씩, 읽어낼 수 있나.'
```
부끄럽다. 
생각해보면, 많은 부분을 GPT 에게 맡겼다. 
그걸 내가 할 수 있다고 오해 했었다. 
나는 많은 부분에서 어쩌면, 오역, 하고 있었다. 
대략적으로, 느낌적으로 해석하고 있었다. 
```










### 방법 요약 
```
1. 회고에 필요한 '속마음 데이터' 준비하기
	1.1 프로젝트 중 '감상'을 ⭐편하게⭐ '나열' 한다.
	1.2 자연스럽게, '나열된 감상' 을 '자연스럽게!!!!!' '분류' 한다. 
		- '좋았던 것, 아쉬웠던 것' 을 기준으로 분류. 
		- 그 이외에, '4L(liked, lacked, learned(배운점), longed for(앞으로 바라는 점)' , '5F(Facts(사실), Feelings(느낀점))' 등으로 분류할 수 있다. 
		- 이때, 특정 분류의 이론이 중요한게 아니다. 솔직한 생각을 적고 -> 단지, 이름표를 붙이는 것 뿐이다. 

👉 여기까지 오면, 회고에 필요한 '경험 데이터' 가 준비 됨. 이제, 'KPT' 방식으로 분류해볼 것 임 


2. '좋았던 것' 은 -> 'Keep(잘 해와서, 유지하고 싶은 것)'  으로 분류 
	- 여기에 들어간 경험 데이터는 '잘 유지하면 됨'

3. '아쉬웠던 것' 은, -> 'Problem(앞으로 개선되면 좋을 점)' 으로 분류 
	- '앞으로 개선' 이 포인트 
	- 이를 위해 '과거에, 문제에 이르는 과정' 을 자세히 기록

4. 'Problem' 을 이렇게 해결해보자! 라는 'Try' 를 기록 
	- problem 의 '원인' 및 '구체적인 action' 까지 도출 
	- 포인트는 ⭐'구체적인 action'⭐
```
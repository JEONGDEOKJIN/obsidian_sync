


# 해야 하는 것 
1) sequelize 로 특정 id 를 가진 user 가 기록한 포스팅 게시글 모아 보기 

2) foreign key, 테이블 join


# 오늘 명상 키워드 (1일 1키워드)
```
근육 하나 하나를 느낌
```
(노션 일지 : https://bit.ly/3AczLxK)



# 1일 루틴 
## 누적 복습 
### About this project 
```
- 필요성 
	- 내가 배운 것을 누적해서 복습 할 수 밖에
- 방법 
	- 벨로그 
	- 깃헙
	- 게시판 4단계 (ex : https://github.com/JEONGDEOKJIN/230329_cumulativeReview_forRocketCurve
)
```


- 코드 배울 만한거 복습 해서 -> 개인 포트폴리오 사이트에 쌓아둬야 함 (⭐⭐⭐⭐⭐  굉장히 중요함)

--- 

## 정보처리기사 

### About this project 
```
- 필요성 : 컴공에 '준하는' 지식 필요 
- 공부목표 
	- 1일 1강 
	- 키워드는 2개 
	- 방법은 명지대 기록학과 교수님 추가 참고
```



## CSS or 프론트 엔드 코테
### About this project

```
- 필요성 : CSS 도, 문제는 반복된다. 비슷한 문제를 반복문으로 풀기도 하지만, 누군가는 map 함수로 푼다. CSS 도 마찬가지 일 것. 
- 공부 목표 
	- 좀 더 효율적인 방식을 찾아야 한다. 
	- 매일 하나씩 새로운 방식을 학습한다. 
	- EX) 1분 코딩 
	- EX) TailwindCSS
```


## 프로그래머스 or 제코테 
### About this project 
```
- 필요성 : 개발자 기본임 
- 목표 
	- 프로그래머스 레벨 3 ~ 4 
	- 틀린 문제, 더  효율적으로 풀어야 하는 문제를 반복

- 작성 목차 
	- 문제 및 출처 
	- 내 풀이 
	- 다른 사람 풀이로 부터 배운 점 

- 풀 문제들 
	- 제코배 : https://www.notion.so/1-1-626bcf4969214bfda4f382ff8aea04a9?pvs=4
	- 프로그래머스 
```


## 개인 미니 프로젝트 
### About this project 
```
- 현재는, 웹사이트 포트폴리오 만드는게 목표
- canvas, three.js 활용하기!
```



## 정리 & publish ( 현재는 벨로그)
### About this project 
```
- 키워드를 골라서, 그날 배운 걸 정리한다. 
- '지식' 이 되려면 '목차' 는 
	- ⭐'문제상황⭐ - 원인 - 해결 - 정리 및 시사점' 의 형식을 띄어야 한다. 

- publish : 벨로그 
- 전체 프로젝트 한눈에 보기 : 노션 ( https://www.notion.so/DJ-2-Vision-to-Task-cbacaebd84c34914b219b2ad6d982c6b?p=e25b993ef3654e28a03849ce60236fa3&pm=s)
- 코드 검색 : codepen
- 전체 저장 : 깃헙
```





# 주간 루틴 
## 예습 


--- 


# 🎏 수업 진도 or 프로젝트 기록 

## ◼ 웨스앤더슨, MW 프로젝트 기록 모음 

[[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_4월(웨스앤더슨 프로젝트)/KGA_8주차(4월3째주_웨스앤더슨)/202304210957_금요일_웨스앤더슨]]
[[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_4월(웨스앤더슨 프로젝트)/KGA_8주차(4월3째주_웨스앤더슨)/202304190822_수요일_웨스앤더슨_프로젝트 중]]
[[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_4월(웨스앤더슨 프로젝트)/KGA_8주차(4월3째주_웨스앤더슨)/202304200852_목요일_웨스앤더슨프로젝트]]
[[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_4월(웨스앤더슨 프로젝트)/KGA_8주차(4월3째주_웨스앤더슨)/202304180938_화요일_기록_웨스앤더슨]]
[[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_4월(웨스앤더슨 프로젝트)/KGA_8주차(4월3째주_웨스앤더슨)/202304170931_월요일_일일 기록]]
[[202304140821_금요일_웨스앤더슨_5일차]]
[[202304130827_목요일_웨스앤더슨3일차_일지]]
[[202304120804_수요일일지_웨스앤더슨플젝]]
[[202304100928_월요일_수업_웨스앤더슨_플젝_시작_]]
[[202304110825_화요일_일일일지_웨스앤더슨_프로젝트_기록]]


## ◼ node.js 수업 관련 정리 상황 

``` css
1. '게시판' 만들 때, 'MVC 패턴' 을 제대로 익혀서 -> 이걸, '글' 로 쓰고 -> 이걸 '반복' 해서 눈에 바르자. 

2. '판례' 를 공부한다고 생각하자. 첫 술에 완벽할 수는 없다. 많이 사용하는 패턴을 익숙할 수 있게 '반복' 하자. 그래서, 내것으로 만드는 수 밖에 없다. ⭐⭐⭐⭐⭐ 
	- 최소 목표 10 회독 
	- 모든것이 아니라, '자주 사용 하는 것' ⭐⭐⭐ 

3. [템플릿 공부] 설명하는 코드스니펫도, '하나의 모듈' '하나의 템플릿' 처럼, 하면서, '상위 목차들의 넘버링이, 코드 스니펫 넘버링에 영향을 주지 않게' 하자. 	
	- ex) 코드 스니펫 설명란에는, 무조건, 숫자 넘버링이 1 부터 시작 할 수 있게. 
	- 비슷한 패턴이 반복된다. 동시에, 상황의 특수성을 반영한 근거를 기재하고 싶다. '의사결정 상황', '상황별 근거' 
	- '상황과 일반론은 템플릿화' 되어 있고, '그 순간순간의 판단 및 근거, 과정' 을 기록 

4. 쿼리문 작성에서 많이 막힌다. MVC 모델을 계속 쓸거면, 쿼리문 제대로 익히자 ⭐⭐⭐ 

5. 날짜별로 기록하지만, 나중엔, '주제별' 로 기록하게 될 것. 그 주제는 그곳에 누적하게 될 것 ⭐⭐⭐⭐⭐
	5.1 이 관점에 동의한다. 
	5.2 '완전하게 이해하고, 완전한 글을 작성한다.' 라는 관점이 있고, '이해도가 떨어지는 것도 반영된, 완전한 글' 을 작성한다는 관점이 있다. 나는 무엇을 택할 것 인가. ⭐⭐⭐⭐⭐ 




```


```
[230518 update]
1. node.js 관련 http 같은 완전 기초 수업은 못 따라감 (5/1 ~ 3 수업)
2. node.js 관련, 5/4 study 폴더에는 어느 정도 정리를 했으나, 100% 는 아님. 
	- 로컬 폴더명 : 230504_study
	- 깃헙 url : https://github.com/JEONGDEOKJIN/230504_STUDY
3. MVC 디자인 패턴 관련 
	- 당일 필기는 3시 까지 적었고, 그 다음 1~2시간 필기는 적지 못 함
	- 당일 수업은 70~80 정도 밖에 이해를 못 했다고 생각함
	- 복습은 못 했음. 
	- 로컬 폴더명 : 230508_MVC_3시전까지필기_교수님자료추가
	- 깃헙 url : https://github.com/JEONGDEOKJIN/230508_MVCpattern_notetakingBefore3pm_professor-sNoteAdd

4. MVC 모델 중 model 파트 부터 나가고 있었고, model 파트에서 delete 쿼리문에서 막혔음. (5/12)

5. 0512에 JWT 관련 수업을 했음. ⭐⭐⭐ 
	- 토큰 발행 및 veiryfy 파일이 2개 임! 
	- verify 는 'JWT 폴더' 
	- 더 완전하게 구조를 파악하려면, '모델링, 그림' 을 그려봐야 할 것 같음 (5/15) 

6. 0515 에 refresh token 관련 수업을 했음. 
	1) 어떤 효과가 있는건지 아직 명확하게 파악을 못 했음. 

7. crypto 와 bcrypt 수업을 했음 (230516 수업)
	- bcrypt 가 실무에서 더 많이 쓰인다고 했음. 
	- 세션 대신 bcrypt 를 써보라고 하셨는데 못 해봤음 
	- session 방식과 이 crypto, bcrypt 방식을 비교해볼 수 있다고 하셨는데, 못 해봤음. 📛📛📛 
	- practice 해보는 과정에서 오류가 있어서 수정하다가 못 했음 (https://github.com/JEONGDEOKJIN/studyNote/tree/master/230516_crypt_practice_01)

8. '페어 프로그래밍' 해서, 정현이 한데, 'MVC' 활용해서, '게시판' 만드는 것 많이 배움 (23-05-18) 
		- 중요한 것 : 그 흐름에 맞게, 생각하고, 흘러가야 한다는 것. ⭐⭐⭐ 

9. 'SQL 쿼리문' 을 활용해서, '게시글 테이블'과 '유저 테이블'을 연결해서 > '특정 userID' 입력하면, 그 userID 가 적은 게시글을 모두 보여주기 예제 
	- 깃헙 주소 : https://github.com/JEONGDEOKJIN/studyNote/commit/613661a742e7d0bbaa5034a75c79802583710353 (여기에 SQL 필기 했음)
	- 연결하는 예제는 여기에 했음 : https://github.com/JEONGDEOKJIN/studyNote/tree/master/230517_class_pairprogramming_makeBoard
	- 📛 sql 문법들 다 정리 못 했음. 다 못 써 봤음. 

10. sequelize 적용해서, 특정 id 유저의 게시글 조회하면 나오게 하기 
	- 깃헙 주소 (예제 코드도 여기에 넣음) : https://github.com/JEONGDEOKJIN/studyNote/tree/master/230519_class


```

<br>

### 필기 모음 

- MCV 디자인 패턴 첫 수업
	- [특이사항] 
		- 3시 이전 수업 밖에 못 적음 
		- 230511 필기에 다시 합쳐서 이해해보자
	- [[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_05월/KGA_11주차(5월 2째주_node.js )/202305080933_월요일_node.js_MVC 디자인 패턴 수업한날_]]
- MVC 디자인 패턴 본격적으로 복습 
	- Model 모듈 공부
		- [[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_05월/KGA_11주차(5월 2째주_node.js )/202305110932_목요일_node.js_개인토이프로젝트_MVC 연습 게시판 만들기]]

- JWT 토큰 발행 및 VERIFY 수업 필기 
	- [[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_05월/KGA_11주차(5월 2째주_node.js )/202305120848_금요일_node.js_1)MVC 복습_2) 토큰발행 및 검증(verify)]]
	- 1회독만 한 상태고, 모델링 설계, 좀 더 배워서, 적용해보자. 그래야, 구조를 이해할 수 있을 것 같음 

- refresh token 관련 
	- [[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_5월/KGA_12주차 (5월 3째주_node.js_다시, 새롭게, 이제, 시작하자.)/202305150925_월요일_node.js_JWT, 토큰,refresh token,]]
	- 깔끔하게 돌지는 못 했고, 주요 흐름을 따라가 봤음 
	- refresh token 으로 뭐가 어떤 결과가 나오는지는 잘 이해를 못 했음. 

- Crypto, bycrypto 
	- [[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_5월/KGA_12주차 (5월 3째주_node.js_다시, 새롭게, 이제, 시작하자.)/202305160922_화요일_node.js 1) crypto 2)bcryt_이거복습아직못함]]
		- bcrypt 방식을 session 에 결합하는 거 아직 못 함 

- 게시판 만들기 페이프로그래밍 | MVC 관련해서 좀 더 배운 날 
	- [[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_5월/KGA_12주차 (5월 3째주_node.js_다시, 새롭게, 이제, 시작하자.)/202305170915_수요일_node.js_페어프로그래밍으로_게시판만들기_MVC에대해좀더배울수있었음]]

- SQL 쿼리 문법에 대해 배움 | 그 중 POST 테이블과 BOARD 테이블을 연결하는 참조 문법 을 배움 | 이걸 활용해서, 저번에 만든 게시판에서 연결하는 예제를 해봄 
	- [[5. githubSync_gitBook/12_KGA_웹개발 블록체인 교육과정/KGA_5월/KGA_12주차 (5월 3째주_node.js_다시, 새롭게, 이제, 시작하자.)/202305180857_목요일_node.js_SQL 문법_board 테이블과, userList 테이블 연결해서, 특정 userID 를 가진 사람의 게시글을 모두 가져오기]]




## ◼ 주간 할일 모음  

- [ ] Bcrypt 를 session 에 적용하는 걸, 3번 정도 반복해봐도 좋을 거 같음 
- [ ] 흥달쌤 데이터베이스 수업을 들어도 좋을거 같음 
- [ ] 페어프로그래밍에서, 게시판 만드는 과정, 정리해서, 정현이 한테 알려줘야 함. 



--- 

# 1️⃣ 수업 | sequelize 방식 적용해서, 특정 user 가 쓴 게시글 가져오기 


### 잘 안 되는 것 | 궁금한 것 

```
1. '테이블 간 관계' 맺어주는 거 개념이 잘 안 잡혀.

2. 'sequelize ORM 모듈' 을 사용하면, mvc 를 사용 안 하는 건가? 
	- 상호 같이 사용할 수 있다고 함. 

3. 전체, 작업 flow 를, '그림' 으로 그리고 싶어.
	- 이걸, usecase 를 쓰는건가? 
	- class? 
	- 아니면, 그냥 화살표? 


```

### 2차 정리 



- class, static 문법 정리 

``` js
<script>

// 클래스 선언, 정의
	class a {
		 // class a 안에 contructor 생성자 함수 선언   
	    constructor(){
	
	    }
	    // 함수를 b 에 넣음 
	    b = function(){
	        console.log(this)
	    }
	
		// static 으로 c 에 무명함수? 선언❓
	    static c(){
	        console.log(this)
	    }
	}

// 실행 해보기 
	// 클래스 a 단에서 메소드에 접근해서 실행해보기 
		// a.b();   // 실행 안됌
		a.c();   // 실행 됨, 클래스 자체에서 실행해야 된다. 

	// 클래스 a 를 복제해서 만든 인스턴스에서 실행해보기 
		// 복제하기? | 인스턴스 만들기?  
			let d1 = new a();
			let d2 = new a();
			let d3 = new a();
			let d4 = new a();
			let d5 = new a();   
				// 1. 이렇게 복제된 d1, d2, d3 안에는 b 가 들어 있음 
				// 2. 그런데, c 는 없음. | 
				// 3. d2.c 이렇게 실행해도, 실행이 안 됨

		// 실행 
			// d2.c   // 안 돼
			d.b();    // 복제 한거에서 실행이 됨

</script>
```






### sequelize 접속 방식 1차 요약 

``` 
1. .env 에서 접속에 필요한 정보 암호화 

USER=root
PASSWORDS=mysqlpwdj
DATABASES=test18
HOSTS=127.0.0.1

```


```
2. models > config.js 에서 dotenv.config 로 접속할 정보를 기록해서 남겨둔다. > 그리고 exports 한다. 

const dot = require("dotenv").config();

const config = {
    dev : {
        user : process.env.USER, 
        password : process.env.PASSWORDS, 
        database : process.env.DATABASES,       // ⭐⭐ key 이름을 변경하면, 여기도 변경 
        host : process.env.HOSTS,
        
        // USERNAME : "root",
        // PASSWORD : "mysqlpwdj",
        // DATABASE : "test18",
        // HOST : "127.0.0.1",

        // 사용하는 데이터 베이스 
        dialect : "mysql"
    }
};

module.exports = config;
```


```
3. models > index.js 에서 시퀄라이즈 객체 만들어서, > db 객체에 sequelize 객체 넣고 > db 를 export 시키기 
	- 시퀄라이즈 객체를 왜 models > index.js 에서 만들지? 

// 시퀄라이즈 객체 생성
    // config 값으로 만들어줌. 
    const _sequelize = new sequelize (
        config.dev.database, 
        config.dev.user,        // ⭐⭐⭐ 여기를 수정 하니까 연결 됨 
        config.dev.password, 
        config.dev
    )


module.exports = config;

```


```
4. models > users.js 에서, sequelize 모듈 가져와서, sql 대신 사용 
```







- 연결 확인 
![](https://i.imgur.com/SwzAt3d.png)
따라가는 키는 id 로 
근데, 이게 안 나오네

```
[해결]
- 기존이 sql 에 있던 table 을 지우고, 만드니까, 됨. 

```



ajax 사용  jquery 만 가져옴 
```
<script src="http://code.jquery.com/jquery-latest.min.js"></script>
```





### sequelize 접속 에러 

- 문제 상황
```
- pw 는 문제 없었음. 
- config 를 console 에서 찍어보니까, 뭐가 있고, 없고를 확실히 알 수 있음 
- 키 이름이 어딘가 중복되어 있어서 안 되었는데 > env 를 변경하고, 다른 연관된 key 들도 변경했어야 했음. ⭐⭐⭐⭐⭐ 
```

<br>

- 에러 코드 
```
 original: Error: Access denied for user ''@'localhost' (using password: YES)
      at ClientHandshake.execute (C:\Users\user11\Desktop\kga\studynote\230519_class\node_modules\mysql2\lib\commands\command.js:29:26)
      at Connection.handlePacket (C:\Users\user11\Desktop\kga\studynote\230519_class\node_modules\mysql2\lib\connection.js:489:32)
      at PacketParser.onPacket (C:\Users\user11\Desktop\kga\studynote\230519_class\node_modules\mysql2\lib\connection.js:94:12)
      at PacketParser.executeStart (C:\Users\user11\Desktop\kga\studynote\230519_class\node_modules\mysql2\lib\packet_parser.js:75:16)
      at Socket.<anonymous> (C:\Users\user11\Desktop\kga\studynote\230519_class\node_modules\mysql2\lib\connection.js:101:25)
      at Socket.emit (node:events:513:28)
      at addChunk (node:internal/streams/readable:324:12)
      at readableAddChunk (node:internal/streams/readable:297:9)
      at Readable.push (node:internal/streams/readable:234:10) {
    code: 'ER_ACCESS_DENIED_ERROR',
    errno: 1045,
    sqlState: '28000',
    sqlMessage: "Access denied for user ''@'localhost' (using password: YES)",
    sql: undefined
  }
}
```

<br>

- 해결 상황 캡쳐 : env 파일에 맞게, USER, PASSWORDS, DATABASES, HOSTS 이렇게 이름을 맞춰줌 
![](https://i.imgur.com/o0LQHXA.png)

<br>

- ENV 이름을 변경했으니, process.env.USER 이렇게 이름 맞춰줌 
![](https://i.imgur.com/QI6QC4J.png)

<br>

- 해당 config 를 index.js 에서 require 해서 쓸 때도, 변경한 key 이름을 반영 
![](https://i.imgur.com/9EKxFUn.png)





### 수업 에러 

대문자 S 로 해줘야 함 


![](https://i.imgur.com/ohN4r1Z.png)




# 2️⃣ 자습 | 'sequelize 모듈 활용해서, 특정 user 가 쓴 게시글 전부를 가져와보기' 에 대한 글 작성


## 목차 
```
- Intro 
- 문제 상황 
- deep dive 한것들 모음 
- 추가 이해가 필요하다고 생각되는 것들
```

<br>
<br>


## Intro 

1. '불완전한 이해를 담아낸, 읽기 쉬운 글' 을 쓰자. 
	- 부족한 이해는 회독이 높아지면, 자연스럽게 차오를 것 이고, (여전히 불완전 할 테지만) 조금 더 차오른 이해를 반영해서 다시 글을 개정하면 된다. 

2. 예상 독자는 `1달 동안 js 를 하지 않고, 기억이 가물가물한, 그래서 살짝 불안한 나 자신` 이다. 단순 코드 스니펫 복사가 아니라, 어떤 폴더에 넣어야 하고, 해당 명령어를 cmd 에 넣어야 하는지, vs 메인 창에 넣어야 하는지 등 까지 기재해야 한다. 

3. 향후, 다음 글에, 반복되는게 있으면, 수정하면서 쓰면 될 것. 함수나, 클래스 처럼. 

4. 코드 스니펫도 중요하고, 해당 코드를 어떤 디렉토리에 적는지도 중요함 (`디렉토리 구조`)

<br>
<br>


## 문제 상황 (해야 하는 것)

``` css
- 이전까지는 '쿼리문' 을 활용해서, mysql 에 CRUD 를 했다. 
- 이제 sequelize 모듈(?) 을 활용해서, mysql 에 CRUD 를 하는 코드를 짤 것 이다. 

```



<br>
<br>


## 이런 순서대로, 코드를 작성해봤음. 

### 1. 기본 app.js 작업 | 모듈 설치, 서버 대기, 미들웨어 설정 등

#### 순서 요약
``` css
1. npm 설치 및 package.json 설정
2. packsge.json 파일 안에서, script 작성
3. 필요한 설치 '모듈' 확인 및 설치
4. 서버 대기 상태 만들기
```

#### 코드 스니펫 

``` js
// 🔷 필요한 모듈 
    // express ejs sequelize mysql2 dotenv


// 🔷 전역 변수 
    const express = require("express");
    const path = require("path");   // path 는 node.js 의 내장변수

    const app = express();


// 🔷 view 엔진 설정 
    // view 엔진 경로 설정 
        app.set("views" , path.join(__dirname , "page"));
            // __dirname(현재 app.js 경로) 와 page 폴더의 경로를 합쳐서, views 폴더를 대체 할거야 

    // view 엔진을 ejs 로 사용
        app.set("view engine" , "ejs");


// 🔷 미들웨어 사용 
    // body 객체 사용 | 깊은 객체 탐색은 false 
        app.use(express.urlencoded ({extended : false}));


// 🔷 서버 대기 상태
    app.listen(8060, () => {
        console.log("8060 에서 듣고 있어요😌")
    } )
```




#### 관련 캡쳐 설명  

- 터미널에서, npm init -y 를 작성하면 > 왼쪽 파일에 package.json 파일이 생김 
![](https://i.imgur.com/kiz19jd.png)


- "start": "node app.js" 이렇게 작성하면 > cmd 에서, npm start 를 하면 > node app.js 를 실행시킬 수 있음.
![](https://i.imgur.com/Owfiq7c.png)


- 터미널에, express i express ejs sequelize mysql2 dotenv 라고 작성하면, 한꺼번에 설치 가능
![](https://i.imgur.com/FvGfzen.png)


- "__dirname(현재 app.js 경로) 와 page 폴더의 경로를 합쳐서, views 폴더를 대체 할거야" 이걸 위해 page 폴더 만들기   
![](https://i.imgur.com/sYHLMhH.png)



### 2. sequelize 기본 작업 | 

#### 순서 요약 

``` css
1. .env 파일 만들어서, 필요한 정보 암호화 
2. .env 에서 작성한 내용을 가져와서, config 객체 안에 담고, export 한다. (@'models > config.js')
3. index.js 에서 config.js 내 export 한 걸 가져와서, 1) 2) 3) 한다. 



```


#### 각 순서 설명 

##### 1. .env 파일 만들어서, 필요한 정보 암호화 

- 코드 스니펫 
``` js
// .env 의 위치]
	//루트 디렉토리 또는 기본 애플리케이션(보통 app.js) 과 동일한 레벨 설치되어야 함 

// mysql 접속시 필요한 요소를 적기 
	USER=root     // mysql 접속할 때, 처음 database 이름 
	PASSWORDS=mysqlpwdj     // 내 mysql 비번
	DATABASES=test18     // workbench 에서 shcema 로 만든 내 데이터 베이스 이름
	HOSTS=127.0.0.1     // 이 기능은 잘 모르겠음 
```

- 디렉토리 구조 
![](https://i.imgur.com/DfLfaaf.png)












##### 2. .env 에서 작성한 내용을 가져와서, config 객체 안에 담고, export 한다.

- 코드 스니펫 
``` js
const dot = require("dotenv").config();     // dotenv 모듈 중 config 메소드 실행시켜서, .env 파일에 쓴거 가져올 수 있는 상태로 만들기

const config = {
    dev : {
        username : process.env.USER, 
        password : process.env.PASSWORDS,  // ⭐⭐ key 이름을 변경하면, 여기도 변경 ❓❓
        database : process.env.DATABASES,  
        HOSTS : process.env.HOSTS, 

        dialect : "mysql"       // 사용하는 데이터 베이스
    }
}

module.exports = config;
```


- 디렉토리 구조 
![](https://i.imgur.com/u2HfXpM.png)


##### 3. 'models > index.js' 에서 'sequelize 객체' 만들고, db 객체에 sequelize 객체 넣고, db 를 export 시키기 







#### 코드 스니펫 

#### 관련 챕쳐 설명






<br>
<br>


## Deep dive 한 것들 모음 


### class 의 static 문법 

``` js
<script>

// 클래스 선언, 정의
	class a {
		 // class a 안에 contructor 생성자 함수 선언   
	    constructor(){
	
	    }
	    // 함수를 b 에 넣음 
	    b = function(){
	        console.log(this)
	    }
	
		// static 으로 c 에 무명함수? 선언❓
	    static c(){
	        console.log(this)
	    }
	}

// 실행 해보기 
	// 클래스 a 단에서 메소드에 접근해서 실행해보기 
		// a.b();   // 실행 안됌
		a.c();   // 실행 됨, 클래스 자체에서 실행해야 된다. 

	// 클래스 a 를 복제해서 만든 인스턴스에서 실행해보기 
		// 복제하기? | 인스턴스 만들기?  
			let d1 = new a();
			let d2 = new a();
			let d3 = new a();
			let d4 = new a();
			let d5 = new a();   
				// 1. 이렇게 복제된 d1, d2, d3 안에는 b 가 들어 있음 
				// 2. 그런데, c 는 없음. | 
				// 3. d2.c 이렇게 실행해도, 실행이 안 됨

		// 실행 
			// d2.c   // 안 돼
			d.b();    // 복제 한거에서 실행이 됨

</script>
```


<br>
<br>



### '객체 지향 프로그래밍' 과 'class'  

- 참고한 강의 
```
생활코딩 객체지향 프로그래밍 : https://bit.ly/3ot3tMJ
```

- 영향을 받은 공부 frame
``` css
- '정보(data) 시스템' 의 본질 중 하나는 '정보(data)' 를 만들고(create), 읽고(가져오고, read), 수정하고(update), 삭제하는(delete) 것 임. 이 관점에서 objet 기술을 바라볼 수 있다. 

- 인지능력, 시간, 에는 한계가 있음. 또한, 의미없이 타이핑을 시간을 가질 것 인지, 생각하고, 도끼날을 베는 데에 시간을 쓸 것 인지. so, 내가 타이핑 하는 것에 너무 집착하지 말자. 

```




#### '객체' 가 필요한 이유 : `정리 정돈` 

``` css
사람의 '인지 능력에는 한계'가 있다. 새로운 문제, 새로운 일을 잘 해결하려면, 받아들일 수 있는 '여유 공간' 이 있어야 한다. (매번 인지 능력을 full 로 쓰면, 새로운 것을 받아들이기 힘들다.)

코드를 짜게 되면 시간이 갈 수록 '복잡' 해진다. 
내가 짠 코드를 '한 번에 이해' 할 수 있게, '단순' 하게 만든다면, 내 인지 능력을 '새로운 문제 상황' 에 꺼내쓰기 쉬워질 것 이다. 

그래서, 코드를 '단순화' 해서 이해하는 것은 중요하다. 

이러한 과정을 '정리정돈' 에 비유할 수 있다. 마구잡이로 쌓인 물건들에, 규칙을 부여해서, 각 구역에 맞게 '정리정돈' 하는 것. 그래서, 쉽게 꺼내쓸 수 있는 것. 

프로그래밍에서는 '다양한 정리정돈 도구' 들이 있다. 객체는 '복잡해진 코드'를 '정리정돈'하는 '도구' 중 하나 이다. 
```


#### '객체' 란? 

``` css
'서로 연관된' '변수와 함수를 그룹핑' 하고, '이름' 을 붙인 것. (by 생활코딩)
```



#### '객체의 특징'

1. '배열' 은 단순값을 저장할 때, 배열은 '그 값에 이름까지 있으면 좋을 때' | 즉, ⭐ '이름'⭐ 이 있는 정보를 정리정돈 할 때.  
``` js
// 동일한 값을 '배열' 에 저장할 때와 '객체' 에 저장할 때의 차이

	// 배열 
		const memberArr = ['egoing' , 'graphittie' , 'leezche'];
	
	// 객체 
		const memeberOjb = {
			name : 'egoing', 
			develoer : 'graphittie', 
			designer : 'leezche'
		}
		// [해석]
			// 이렇게, 'egoing' 은 '이름이다.' 라는 식으로, '부연설명' 할 수 있음. ⭐⭐⭐ 
```


2. '객체' 는 ⭐⭐'그룹핑(grouping)된 결과물' ⭐⭐ |
	- 무엇이 grouping 될 수 있는가? 무엇이 들어갈 수 있나? ⭐1) 함수 2) 변수⭐ 가 들어갈 수 있음. 
``` css
- PI(), random(), floor(3.9) 같이, 수학과 관련된 '특정 기능' 들이 이미 존재함. 
	- 각 메소드는 하나의 기능만을 수행. 
	- 독립적인 역할을 함

- 자바스크립트를 만든 사람들은, 이것을 'Math' 라는 이름으로 ⭐'그룹핑'⭐ 하면 좋을 것 이라고 생각함. 그래서, Math 객체 안에, 해당 메소드를 넣음.

- 그래서, 해당 메소드를 실행할 때는, Math.PI, Math.random() 으로 실행하게 됨. 
```


3. this 
	- this 는 `this 가 속해있는 메소드` 가 `속해있는 객체` 를 가리키는 `예약어`
	- 해당 객체의 `내부 참조` 를 하고 싶을 때 사용한다. 
``` js
// this 는 ⭐⭐1) 'this 가 속해있는 메소드' 가 2) '속해 있는 객체'⭐⭐ 를 가리키는 예약어
	// '객체 자기 자신' 을 가리킴 
	// ex) 지시 대명사 같은 느낌. ex) 나는, 저는 의 느낌

// this 는 언제 필요하지? 
	// 객체 내부 설계 중 '객체 메소드' 를 설계 할 때, ⭐'객체 내부의 변수 또는 메소드' 에 접근⭐할 필요가 있을 때 

// 예시
	// 문제 상황 : 게임 유저의 1번째, 2번째 점수를 합산해서 '총점' 을 만든다. 

	// this 를 쓰지 않는 경우 
		const dj = {
	        userid : "dj", 
	        firstScore : 10, 
	        secondScore : 20, 
	        sum : function(f, s) {
	            return f+s
	        }
	    };   
	
	    console.log("sum" , dj.sum(dj.firstScore, dj.secondScore))

	// this 를 사용하는 경우 
		const dj = {
	        userid : "dj", 
	        firstScore : 10, 
	        secondScore : 20, 
	        sum : function() {
	            return this.firstScore + this.secondScore
	        }
	    };   
	
	    console.log("sum" , dj.sum());

// 요약 
	// 1. this 는 '변수와 함수를 groupgin' 한 것 임. 
	// 2. 이러한 관점에서, '객체 메소드를 create' 할 때, 이미 객체 안에 있는 '변수 또는 함수' 를 가져와서 쓰고 싶을 때 
	// 즉, '⭐객체가 가진 정보를 내부 참조⭐' 하고 싶을 때

```


4. 객체를 CREATE 하는 종류와 특징 
``` js
// 1. 수작업, 가내 수공업 

	// 1.1. CREATE  
	const dj = {
		userid : "dj", 
		firstScore : 10, 
		secondScore : 20, 
		sum : function() {
			return this.firstScore + this.secondScore
		}
	}; 

	// 1.2 문제점 
		// ⭐'수 천개의 객체' 가 있는 상황에서 'UPDATE' 를 해야할 경우 ⭐
			// 이 경우, 일일이, 한땀 한땀, 변경해야 함. 


// 2. 생성자 함수(constructor) 사용 
	// 2.1 CREATE 
	
		// 이미 (누군가에 의해) 만들어진 Date 를 사용하는 경우 
		    const d1 = new Date('2023-05-21')
		    // [해석]
			    // 1) 이 순간, '객체가 만들어짐'
			    // 2) '객체의 내부 설계' 는 볼 수 없음. ⭐⭐ 
		    console.log(d1.getFullYear());

		// 내가 constructor 를 만들어서, 객체를 생성하는 경우 
			function Person() {
				this.name = 'dj', 
				this.first = 10, 
				this.second = 20, 
				this.third = 30, 
				this.sum = function() {
			return this.first + this.second + this.third;
				}
			}
			
		    console.log(Person())
				// [해석]
					// undefined 가 나옴. 
		    console.log(new Person())
			    // [해석]
				    // 이 순간 '객체가 CREATE'
				    // '⭐⭐일반 함수를 실행하는 것' 에 더해서 'new' 명령어를 쓰면, 객체가 만들어진다.⭐⭐
				    // 이름이 '생성자 함수' 이고, 함수 니까, 일반 함수랑 실행하는게 비슷한데, '생성자' 함수니까, 앞에 new 명령어를 쓴다. 
				    // new Person() 은 객체를 만들기 때문에, '생성자 함수' 가 된다. 

		// 매개변수를 넣어서 constructor 를 사용해보기 
			    function Person(name, first, second, third) {
			        this.name = name, 
			        this.first = first, 
			        this.second = second, 
			        this.third = third, 
			        this.sum = function() {
	            return this.first + this.second + this.third;
			        }
			    }
				console.log(new Person('dj' , 10, 20, 30))

	// constructor (생성자 함수) 를 사용하면 좋은 점 
		// 1. CREATE 관점 
			// '다수의 객체' 를 만들 때, 한번 정의를 잘 해두면, 쉽게 만들 수 있음. 

		// 2. Update 관점 
			// constructor 함수에 새로운 속성을 추가하면(함수의 선언을 변경하면) -> 해당 함수가 실행되면, 변경된 내용이 반영되어서, 객체를 만들게 됨 
			// 즉, ⭐⭐ 한땀 한땀 찾아가지 않고, '일괄 수정' 이 가능 ⭐⭐⭐ 


// 3. class 사용 
	// 아래 필기 참고 
	// 참고로, js 는 프로토타입 기반 
	// 다른 언어 사용자들이 잘 적응할 수 있게 class 를 추가해놓은것

```


5. `constructor(생성자 함수) 에 의해 대량생산(create)된 객체`를 `일괄 수정(update)`함에 있어 `prototype` 이 필요한 이유와 특징  
``` css
// prototype 이 필요한 이유 ⭐⭐⭐ 
	// 새로운 객체 생성 후, 객체의 속성(변수 및 메소드) Update 작업을 '성능 및 메모리 유지' 하면서 하기 위해 ⭐⭐⭐⭐⭐ 

	// 추가 설명
		// 1. constructor 함수를 이용해서 객체를 만들었음. 
		// 2. '원본 constructor' 함수를 유지하면서(원본 constructor의 설계를 건드리지 않고), 새로운 객체(인스턴스)에만 수정(Update) 를 하고 싶음. 
			// 원본을 건드리지 않는다는게 중요한 이유는, 'constructor 는 일괄 수정이 가능하여, 수작업 객체 생성의 한계를 극복' 했었어. 이 점을 활용하면, 사실, 넣고 싶은 메소드를, constructor 원형에 넣으면 되는거지. 그런데 그렇게 안 하는 이유는? 
				// 1) 원형에 넣으면 -> 객체가 실행될 때 마다 실행됨 -> 성능 저하 및 메모리 과도하게 사용 ⭐⭐⭐ 
				// 2) 따라서, 원본 건드리지 않고, prototype 을 쓰면, 한번만 실행됨 -> 성능 및 메모리 유지 가능 ⭐⭐⭐
		// 3. 이 작업을 '⭐모든⭐ 인스턴스(생성자 함수로 만들어진 결과물)' 에 하고 싶음.


// prototype 에 추가해서, 새롭게 기능을 만들고 싶은 경우 
	// 그냥, 그 위에 만들면 됨. 
	
	// 다만, 중요한건, '특정 객체의 메소드를 실행' 할 때 임. 
		// 즉, 1) 해당 메소드가 속한 '객체' 에, '지금 실행하려는 메소드'가 있는지 본다 
		// 2) 없다면, 해당 객체의 프로토타입에 '지금 실행하려는 메소드' 가 있는지 본다. 


// 예제 코드 
	// https://bit.ly/42SG4mU 참고 


// 정리하면 
	// 1. prototype 는 1) '원본 constructor 설계' 에 영향을 주지 않으면서, 2) '모든 인스턴스' 에 3) '추가 속성'을 만들 수 있음. (CREATE) 
	// 2. 만약, 공통 prototype 위에, '추가로 기능을 넣고 싶으면', 그냥 넣으면 됨 (Update)
	// 3. 다만, 그 메소드가 실행될 때, 
		// 1) 해당 메소드가 속한 객체에 실행하려는 메소드가 있는지 찾고 
		// 2) 없다면, '해당 객체를 만든 생성자 함수'의 '프로토타입' 에 '해당 객체' 가 있는지 본다.  ⭐⭐⭐⭐⭐⭐⭐⭐ 
```


6. 객체 대량 생산(CREATE) 및 관리에서 `PROTOTYPE 의 대체재`인 `CLASS` 
``` css
// 1. class 와 constructor
	// clss 는 constructor 의 대체재 임. 
		// constructor 함수의 기능 ⭐⭐⭐⭐⭐⭐ 
			// 함수 정의 부분 = '객체의 초기 모습을 셋팅', '객체 내부 설계' 
			// 함수 실행 부분 = 이 순간, 객체가 '실제로 생성'된다. 
	// 따라서, class 는 '이 기능'을 '어떻게 대체'하고 있는지를 보는게 중요

	// class 에서 '객체의 초기 모습을 셋팅' 하는 부분은? 
		// ⭐ constructor ⭐
		// ⭐⭐ 객체가 생성되는 순간, 별도로 실행하지 않았음에도, constructor 함수가 실행된다. ⭐⭐⭐⭐⭐⭐ 
	
	// class 에서, '실제로 생성' 되는 건? 
		// 동일 
	
	// 예제 코드 
		// https://bit.ly/3Iux13B


// 2. UPDATE 관련 | class 를 사용해서, '모든' 인스턴스(이미 만들어진 객체) 의 속성을 '공통 변경' 하려면?  

	// 문법 
		// constructor 안에 넣으면 된다. (예제 코드 참고)

	// 특징 
		// 다만, constructor 에 있는 메소드와는 달리, '별도로 호출' 해야 실행됨. 
			// constructor 는 '기본값으로 실행'


// 3. UPDATE 관련 | class 를 사용해서, 인스턴스(이미 만들어진 객체) 중 '하나' 의 속성을 '특별히 변경'하려면?  
	// 문법 
		// 참고 https://bit.ly/3MrxXGU
		// kim.sum = funciton () {} 이렇게 그냥 쓰면 된다. 

	// sum 메소드가 실행되는 맥락 ⭐⭐⭐⭐⭐⭐⭐⭐ 
		// 1. sum 메소드가 속한 kim 객체에, sum 이 실제로 정의되어 있는지 본다. 
		// 2. kim 이라는 객체는 class 에 의해 만들어진 것 이므로 > kim 을 있게 한 class 인 Person 안에 sum 메소드가 있는지 본다. ⭐⭐⭐⭐⭐⭐ 

```


7. class 관련 | '상속'
``` css
// '상속' 이 필요한 경우 

	// 문제 상황 : sum 메소드만 있는 person class 에 avg() 메소드를 추가하고 싶은 경우 
	// 선택할 수 있는 방법 
		// 1. class 정의 부분으로 가서, 애초에 avg() 가 들어갈 수 있게 한다. 
			// 이 방식의 문제점 
				// 1) 원본 클래스를 수정했을 경우, 만약, 이게 라이브러리면, 업데이트가 안 되거나, 업데이트시 만든 메소드가 사라지게 됨. 
				// 2) prototype 과 마찬가지로, 해당 class 가 실행될 때 마다 반복될 것 이기에, 성능 및 메모리 부하를 가져옴 

		// 2. 상속 
			// 문법 핵심 
				// extends 구문을 쓴다. 
				// super() == 부모클래스의 생성자 
				// super. == 부모클래스에 접근 가능
			// 특징 
				// 부모 클래스에 없는 기능을 자식 클래스에 만들고 싶으면(create), 그냥 만들면 됨. 
				// 부모 클래스에서, 기능을 활용해서 update 하고 싶을 때, 기존의 것을 super 로 가져오고, 추가 업데이트를 한다. 
				


```





#### 객체 CRUD 
``` js
// 1. CREATE 
	const memeberObj = {
	name : 'egoing', 
	develoer : 'graphittie', 
	designer : 'leezche'
	}


// 2. READ
	const memeberObj = {
		name : 'egoing', 
		develoer : 'graphittie', 
		designer : 'leezche'
	}

	// designer 에 있는 값 가져오려면 
		// . 사용해서 가져오기 
			memeberObj.designer
		// [ ] 사용해서 가져오기 
			memeberObj['designer']

		// [해석]
			// 두 방식의 차이 

// 3. update 
	memeberObj.designer = 'DJ'

// 4. delete 
	delete memeberObj.designer


```




## 추가적으로 이해하면 좋을 것 모음 

```
1. 쿼리문 대신, sequelize 를 사용해서 CRUD 를 하는 이유는? 

2. 객체 read 할 때, . 방식과 [] 방식의 차이 

3. 객체 반복문 돌리는 방법 
	- 중요도가 떨어져서 넘어감 (https://youtu.be/uvMa1va4CvI)


```
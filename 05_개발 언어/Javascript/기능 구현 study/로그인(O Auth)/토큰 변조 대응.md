
# 문제 상황 
```
로그인 성공했으나, 중간에서 accesstoken 이 탈취되어 변조 및 오염된 경우 
인증시 생성한 jwt 의 signature 와 
인가 api 요청시 클라이언트가 제출한 JWT 의 signature 가 다른 경우가 발생 

이것을 어떻게 검증하고, 유저 flow 를 구성할지가 문제 
```


<br>

# 시퀀스 다이어그램

![[로그인(O_auth)_1.pdf]]


![[로그인(O_auth)_2.pdf]]

![[로그인(O_auth)_3.pdf]]


<br>

# 왜 이렇게 동작하게 되지? 

## 로그인 했을 때 생성한 jwt의 signature 와 인가 api 요청시 프론트가 제출한 jwt 의 signature 를 비교했을 때, '무결성이 필요한 이유' 는? 

'무결성을 검증한다.' 라는 건, 쉽게 말해, 백엔드 입장에서, ''jwt 를 처음 만들었을 때의 accessToken'과 
‘클라이언트에게 주고 다시 받았을 때의 accessToken' 이 달라졌는지를 검사하는 것 이다. 


그러면, '서버에서 만들었을 때'랑, '외부로 나갔다가 서버로 다시 들어왔을 때' 달라졌는지를 왜 보는건가. (오염.. 될 수도 있는거 아닌가.)
accessToken 은 '입장할 수 있는 증표, 권한' 같은 것 이다. 따라서, '백엔드가 발행한 입장 권한이 그대로' 있어야 한다. 사용자가 마음대로 바꾸면 문제가 된다. 

예를 들어 A 사용자에게는 '사용자 권한' 만 줬는데, A 사용자가 자기 마음대로 바꿔서 '관리자 권한' 을 갖게 되는 경우가 문제가 될 수 있다. 
그래서 '무결성이 필요하다.' 


<br>

## 로그인 했을 때 생성한 jwt의 signature 와 인가 api 요청시 프론트가 제출한 jwt 의 signature 를 비교했을 때, '무결성이 검증될 수 있는 이유' 는? 

서버가 만든 토큰을 클라이언트에게 준 이후부터, 해당 토큰은 '충분히 오염될 수 있는 상황' 에 처하게 된다. 
그럼에도, 서버는 '이 증표가 바뀌었나.' 라는 걸 정확히 검증할 수 있어야 한다. 대체 어떻게 할 것 인가. 

이때, '해시함수의 결정성' 그리고 '비밀키는 서버만 알고 있기' 라는 2가지 특징을 사용한다. 

'해시 함수의 결정성' 이란, 쉽게 이야기 해서 '동일한 input 을 해시함수에 넣으면, 언제나 동일한 결과값' 이 나오는 것을 의미한다.
 ex) 동일input-> 해시함수 -> 언제나 동일한 output 

'비밀키는 서버만 알고 있기' 는 해시함수의 input으로 '비밀키' 가 들어가게 되는데, 이것을 '검증하고 싶은 주체인 서버' 만 알고 있게 한다는 것 이다. 

구체적으로는
``` bash
input -> process -> output 의 구조에서 

[input] '밖으로 나갔다가 서버 안으로 들어온 accessToken 의 header + payload' + secretKey 
[process] 해시함수 
[output] signature(문자열로된 토큰) 

가 각 요소가 될 것 이다.
```



이때, 
- secretKey 는 '서버만 알고 있다.'
- '해시함수' 는 '결정성' 이 있으므로, '동일한 input' 을 넣으면, '동일한 output' 이 된다. 
- 따라서, 'accessToken의 header + payload 로 만든 sign' 과 'accessToken 에 있던 sign' 을 비교한다. - 다르면, '변조, 오염' 되었다고 본다.
 (왜냐면, 그 누구도 header 와 payload 에 조작을 가하지 않았다면, 밖으로 나갔다 들어온 accessToken 이라고 할지라도, 
해시함수에 header 와 payload 를 넣으면, 언제나 동일한 sign 값을 출력! 할 것 이기 때문에!) 


<br>

## 다만, JWT 생성에 '대칭키(비밀키)' 를 사용할지, '비대칭 암호화 방식' 을 사용할지에 따라서, 구체적인 방식은 달라질 수 있으나,
서버가 발행하고 검증한다는 점에서 대칭키를 사용하면 된다. (만약, 발행자와 검증자가 다르다면, 비대칭키 방식을 사용한다.)



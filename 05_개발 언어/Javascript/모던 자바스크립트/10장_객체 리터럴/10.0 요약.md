


### 객체 란?  
``` BASH 
- 객체란
	- [데이터 타입 관점] '원시값'을 '제외'한 나머지 값(배열, 객체, 함수, 클래스 등)
	- [구성요소 관점] 객체는 '프로퍼티' 와 '메서드' 의 집합이다. 

- '프로퍼티' 란 '객체'의 '상태' 를 나타내는 '값(data)'
- '프로퍼티' 는 '키' 와 '값' 으로 구성된다. 

- '메서드' 는 1) 프로퍼티(객체의 상태) 를 '참조' 하고 2) '조작' 할 수 있는 동작(behavior)


CF. 
원시타입의 값 : 단 하나의 값만 들어감. 변경 불가능(immutable value). 특정 메모리 주소에 바인딩된 값 자체를 수정 불가능. ⭐⭐⭐ 
객체타입의 값 : 변경 가능(mutable value). 특정 메모리 주소에 바인딩된 값 직접 수정 가능. ⭐⭐⭐

(출처 : 모던 자바스크립트 deep dive p125)
```

![](https://i.imgur.com/d7Gz11x.png)


<br>


### CF. 원시 타입 vs 객체 타입 

- 원시 타입 vs 객체 타입 
```bash  
 - 원시 타입
	- 단 하나의 값만 들어감. 변경 불가능(immutable value) 
	- 만약, 값을 변경하고자 하면 -> 새로운 메모리셀에 값을 다시 만든다. 
	- 특정 메모리 주소에 바인딩된 값 직접 수정 불가능. ⭐⭐⭐

- 참조 타입
	- 원시값 또는 다른 객체가 들어감. 변경 가능(mutable value)
	- 특정 메모리 주소에 바인딩된 값 직접 수정 가능. ⭐⭐⭐


- 원시 타입이 왜 변경 불가능해? 변수에 다시 할당하면, 값이 변경되는 거 아니야?  
	- 변수에 값을 다시 넣어서 값 수정('update') 하는 것은, '재할당' 이다. 
	- 재할당은, 새로운 메모리 주소에, 새로운 값을 넣고, 해당 식별자가 새롭게 생긴 메모리 주소를 바라보게 하는 것 이다. 
	- 따라서, 예전에 저장되어 있던 값은, 여전히 해당 메모리 주소에 유지되어 있고, 새롭게 저장된 값은 새로운 메모리 주소에 저장되는 것 이다. 
	- 참조되지 않는, 이전의 메모리 주소는, 가비지 컬렉터에 의해, 제거 된다. 
	- 따라서, 원시타입의 값은 불변성을 갖는다. 


 - 'immutable value' 란? 
	 - 5 라는 값이, 0x123123123 메모리 주소에 저장되고, number 변수가 0x123123123 주소를 가리키게 되는 경우(number 변수에 5를 할당) 
	 - 설령, number 변수가 메모리 0x345345345 를 가리킨다고 해도 
	 - 0x123123123 메모리 주소에 저장된, 바로 그 값은, 삭제될지언정, 변하지 않는다. (덮어쓰지 않는다.) ⭐⭐⭐⭐⭐ 
	 - 이때, '값의 불변성' 및 '값과 메모리 주소의 불변성' 이 immutable value 임. 
		 - 한번 저장된 값은, 한번 저장된 그 메모리 주소에서, 사라지지 않는다.

// 출처 : 모던 자바스크립트 p124 
```


- 원시 타입에서 '값을 수정' 하고자 하는 경우 -> 메모리 주소, 바인딩된 값, 해당 변수가 참조하는 메모리 주소의 변화 
	- 값 자체를 변경할 수 없느니 -> 메모리를 낭비를 감수하되, 가리키는 주소 자체를 변경
```  js
// 메모리 주소 0x123에 저장된 값은 5, 0x123을 가리키는 변수는  'number' 
// 이것을 number 변수에 5 를 할당했다고 함.
let number = 5; 
console.log(number); // 출력: 5


// 겉보기에는 number 안에 있는 값을 수정한 것 처럼 보임 ⭐⭐⭐⭐⭐⭐ 
// 하지만, 값을 수정한게 아니라, number 가 가리키는 메모리 주소를 변경 시킨 것 임 ⭐⭐⭐⭐⭐ 
number = 6; 
// 따라서, 이 순간 
	// 메모리 주소 0x123 에 저장된 값은 여전히 5 임. 
	// number 가 가리키는 변수는 0x234 이고, 0x234 메모리 주소에 바인딩된 값은 6 임. 
	// 메모리 주소 0x123, 0x234 모두 값이 살아있음! 
	
console.log(number); // 출력: 6 

// 즉, "'어떤 변수' 에 값을 할당 후 -> 수정'"  이라는 현상은 동일해. ⭐⭐⭐⭐⭐⭐⭐ 
// 그 수정을 
	// 1) 실제 값 변경으로 구현 -> mutable value -> 참조 타입 ⭐⭐⭐⭐⭐  
	// 2) (값 변경없이) 가리키는 메모리 주소를 변경으로 구현 -> immutable value -> 원시 타입 ⭐⭐⭐⭐⭐ 
```


- 참조 타입에서 '값을 수정' 하고자 하는 경우 -> 메모리 주소, 메모리 주소에 바인딩된 값 및 해당 변수가 참조하는 메모리 주소의 변화 
	- 변경하고자 하는 값 자체를 변경
``` js 
let person = { 
	age : 30, 
	name : 'Alice'
};
// 이 시점에 메모리 0x345 에는 {age:30, name:'Alice'} 의 값이 저장된 메모리 주소인 0x567 이 저장됨. 
// 그리고 person 은 0x345 를 가리킴. 
// 0x567 메모리 주소에는 {age:30, name:'Alice'} 값이 바인딩 됨. 


person.age = 31; 
// 이 시점에, 변경된 것은, '값' 밖에 없음 
// 즉, 0x567 메모리 주소에 저장된 {age:30, name:'Alice'} 에 '직접 접근' 해서, -> {age:31, name:'Alice'} 로 변경한 것임. 

```


- 시사점 📛📛📛 
``` bash
- 원시 타입
	- 원시 타입은 값을 복사할 때 원본의 무결성을 유지
	- 불변성 👉 스프레드타입 연산, 리액트는 불변성을 지킨다❓ (이 부분에 대해서 알아야 함 📛📛📛)

- 참조 타입
	- 참조 타입은 메모리 효율성과 유연성을 제공하지만, 부주의한 데이터 변경으로 인한 오류를 유발

- 값을 수정(update) 하는 과정에서, 오류가 발생하는 경우가 있을 듯. 
```










# 보완할 것 

- 리액트가 불변성을 지킨다는 것에 대해서 
- 스프레드타입 연산에 대해서





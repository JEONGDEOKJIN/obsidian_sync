

# 자바 스크립트의 탄생
``` bash
웹 페이지의 '보조적인 기능' 을 수행하기 위해서, '경량' 프로그래밍 언어로 도입
```


<br>

# 자바스크립트의 표준화

``` bash
- 마이크로소프트는 자바스크립트의 '파생 버전' 인 'jscript' 를 출시 -> '자바스크립트와 jscript 간 호환이 벽하지 않는' 문제가 발생 -> '크로스 브라우징 이슈' 발생

- '모든 브라우저에서 정상 작동' 하게 하기 위해 -> 넷스케이프 커뮤니케이션즈에서, 'ECMA(비영리 표준화 기구)' 에 자바스크립트 표준화 요청 -> 이후 ECMA 가 표준화 버전 배포  
```


<br>


# 자바스크립트 성장 역사

## 1) 웹페이지 보조 기능 및 기초 렌더링

``` bash 
- 초창기 자바스크립트는 웹페이지의 '보조적 기능' 을 수행함
- 대부분의 로직 = 웹 서버 
- 브라우저는 HTML, CSS 렌더링 역할
```
- 38장 브라우저 렌더링 참고
	- [[5. githubSync_gitBook/05_개발 언어/Javascript/모던 자바스크립트/38장_브라우저의 렌더링 과정/38.0 브라우저 렌더링 과정 요약]]


<br>


## 2) ajax
``` bash
- ajax 의미 
	- asynchronous javascript and XML 
	-  XML : '데이터 교환의 주요 형식'. 플랫폼 독립적. -> 현재, 더 가볍고, 읽기 쉬운, JSON 형식으로 대체

- ajax 의 핵심 
	- 서버와 브라우저가 '비동기' 방식으로 통신할 수 있는 기능
	- Web API 가 제공하는 'XMLHttpResquest' 객체의 프로퍼티 및 메서드를 이용


- ajax 가 해결한 문제
	- '정적 업데이트'에 따른 '블로킹 현상' 및 '깜빡임 현상(flickering)'  
		- '변화된 부분 렌더링(ex. 좋아요 버튼만 업데이트)' 할 때 -> '전체 페이지' 를 서버에 '동기적으로' 요청하고(블로킹 현상), -> 응답 받은 html 기반으로, '처음부터 새롭게 그림' -> 깜빡이는 현상 발생 


- ajax 해결 방식
	- 'DOM 트리에서, 변화된 부분을 업데이트' 할 때 ex) 좋아요 버튼만 업데이트
		1) 변화된 부분의 데이터만, 
		2) 비동기적으로 요청
		3) 필요한 부분만 렌더링 ('동적 업데이트')


- 동적 업데이트 vs 정적 업데이트의 핵심 ⭐⭐⭐
	- 문제 상황 : '변화된 부분(부분 렌더링)' 만 보여주고 싶어! ⭐⭐⭐  
	- 업데이트 방식의 차이
		- '서버에 어떤 데이터를 요청하는가' 의 관점으로 보면, 정적 업데이트는 '새로고침을 통해 전체 HTML 파일'을 요청, 동적 업데이트는 '변화가 필요한 데이터만 요청하기 위해, ajax 를 통해 비동기적으로 요청'
		- '응답 받은 데이터를 처리하는 관점' 으로 보면, 정적 업데이트는 전체 HTML 파일을 렌더링 프로세스에 넣으면 되고, 동적 업데이트는 변화된 부분만 DOM 에서 업데이트 한다. (서버로 부터 HTML 수신 -> DOM 생성 -> 렌더트리 -> 서버로 부터 받은 데이터로 js 에 의한 DOM 조작 -> reflow, repaint -> paint) 
		- '사용자의 UX 경험' 관점에서 보면, 정적 업데이트는 1) 느리고(처음부터 다 받아야 하니까.) 2) 깜박이는 현상이 발생하고, 동적 업데이트는 1) 페이지의 일부분만 변경 ex) 좋아요, 댓글 2) '실시간성⭐⭐' 을 느낌. 
	- 효과 : 동적 업데이트를 통해 사람들이 '실시간성' 을 느끼기 시작 ⭐⭐⭐⭐⭐ 
	- 의의 
		1) 실시간 변화가 동적업데이트에서 오고, 동적 업데이트의 시작이 ajax 임. 
		2) 동적 업데이트가 가능하게 된 것은 '특정 데이터 요청', '비동기 통신' , 'DOM 조작을 통해, 해당 부분만 변경' -> 렌더링되는 부분이 작아져서, 실시간 처럼 느끼게 됨. ⭐⭐⭐⭐⭐ 


- ajax 적용 효과 
	- '웹' 브라우저에서 '데스크톱에 준하는' 성능과 부드러운 화면 전환 효과 ex) 구글 맵스 
	- 웹이 데스크톱의 효과를 따라가기 시작
	- 	'동적 업데이트' 에 따른 '실시간 경험' ex) 댓글, 좋아요 등 의 시작 -> 


- ajax 통신 방식 
	1) 초기화 : open 메서드 사용 | 'rest api' 활용하여 url 설정 | async 매개변수로 '비동기 처리' 관리 
	2) 필요시 헤더 설정 : 'MIME 타입' 설정 
	3) 요청 전송 : send 메서드 | 필요시 '페이로드' 전달
	4) 이벤트 캐치 : onload 메서드 | '응답 완료' 확인
	5) 이벤트 캐치 : status == 200 | '정상 여부' 확인


- ajax 의 한계 및 해결책
	- 'DOM 조작의 비효율성' 과 '코드 복잡성' 
		- [DOM 조작의 비효율] 특정 노드만 변경하려 했으나 -> 해당 노드의 자식 까지 변경됨 -> 불필요한 reflow 발생 -> 불필요한 메모리 소모 
		- [코드 복잡성] DOM 조작을 최소화 하기 위한 다양한 방법이 고안 -> ex) 업데이트 되어야 하는 노드를 모으고, 한번에 innerHTML 처리 -> 이 작업만을 위한 코드가 존재. 코드 복잡성 증가.
	- SPA 가 개발된 계기


CF. JSON 
	- '클라이언트와 서버간 HTTP 통신' 을 위한 '텍스트 데이터 포맷' ⭐⭐ (출처 : 모던 자바스크립트 P818) 
	- '키와 값' 으로 구성된 '텍스트' (출처 : 모던 자바스크립트 p818)
	- 주요 메서드 : JSON.stringfy, JSON.parse
```

- 참고 : 모던 자바스크립트 ajax 파트 [[5. githubSync_gitBook/05_개발 언어/Javascript/모던 자바스크립트/43장_ajax/43.0 ajax 요약]]



<br>


## 3) jQuery
``` bash
- jQuery 가 해결한 문제
	- 'DOM 제어' 를 쉽게 해줌 -> 그에 따라, '크로스 브라우징 이슈' 어느 정도 해결
```


<br>

## 4) V8 자바스크립트 엔진
``` bash
- V8 가 해결한 문제 
	- 웹 어플리케이션의 수요 증가 -> 빠르게 동작하는 JS 엔진이 필요 -> V8 등장으로 어느 정도 해결

- 효과 
	- 데스크톱 어플리케이션 과 유사한 UX 경험
```


<br>

## 5) Node.js
``` bash
- node.js 가 해결한 것 
	- v8 엔진으로 빌드된 js 런타임 환경 -> 브라우저를 벗어나 서버 사이드 어플리케이션에 js 가 사용될 수 있게 됨. 
```
추가 학습 : [[5. githubSync_gitBook/05_개발 언어/Javascript/모던 자바스크립트/02장_자바스크립트 란/node.js 특징]]


<br>


## 6) SPA 라이브러리 및 프레임워크 
``` bash
- SPA 프레임 워크가 해결한 문제 
	- '페이지 부분 렌더링(업데이트)(동적 업데이트)' 시, JS로 'DOM을 직접 조작'의 비효율성 발생 (이전, ajax 시절)
		1) 불필요한 reflow 및 repaint 가 발생 ex) 특정 노드를 취득 및 변경 하면 -> 해당 노드의 자식 노드 까지 변경 -> 자식 노드의 reflow, repaint 라는 불필요한 리소스가 소모됨.
		2) 이것을 최적화 하기 위해 코드가 복잡해짐 ex) 수정되어야 하는 DOM 노드가 100개 인 경우 -> innerHTML 을 100번 사용해서, 100번 DOM 수정 vs '1번의 DOM 수정' 으로 업데이트 할 수도 있음. -> 그런데, 1번의 DOM 수정을 하기 위해서, 고려해야 하는 '코드의 복잡성' 이 증가함 ex) innerHTML 예시


- 이 문제 해결에 있어 중요한 점 
	- 필요한 DOM 만 변경하기
	- DOM 조작 횟수 줄이기


- 이 문제를 해결하기 위해, Virtual DOM 을 사용한 렌더링 프로세스를 개발  
	1) 게임 엔진의 원리(보여줄 화면을, 미리, 만들어놓는다.) 를 응용하여
	2) 리액트 상의 각각의 컴포넌트를 -> React Element 로 만들고 -> 각각의 React Element 를 모아서 Virtual DOM 으로 만들고 -> 최소화된 DOM 조작으로, 실제 DOM을 업데이트 하고 -> paint 한다. 

- 만약, '재조정' 을 해야 하는 경우 
	1) 각각의 컴포넌트를 -> React Element 로 만들고 -> 각 React Element 를 모아서 Virtual DOM 으로 만든다. 
	2) 현재 VDOM 과 기존 VDOM 의 차이점을 모두 파악해서 -> ⭐'하나'⭐ 로 모은다 -> 최소한의 DOM 조작(하나로 모았기 때문에 가능) 으로 실제 DOM 을 업데이트 하고 -> paint 한다. (이게 렌더링 프로세스가 반영된 거지)


- 시사점 
	1) '업데이트가 필요한 노드' 에 대해서만 '렌더링' 이 일어나서 -> 리소스 효율화
	2) '최소한의 DOM 업데이트' 가 이루어짐 
	3) '대부분의 업데이트' 가 부드럽게 이루어짐 


- SPA 프레임 워크가 해결한 것 
	- 개발 규모와 복잡도 상승 문제 발생 
	- CBD 방법론 기반 -> SPA 프레임워크 및 라이브러리 등장
```

- 보완할 점 : Virtual DOM 정리본 보면서, 내용 정확성, 보완
- 실제로 해볼 것 : story book 과 CBD 방법론을 함께 사용해서 개발 진행해보기


<br>


# 자바스크립트와 ECMA script
``` bash
- 자바스크립트는 
	- 클라이언트 사이드 환경에서 실행되는 경우 'core 인 ECMA' 와 '클라이언트 사이드 web api(브라우저가 지원)' 로 구성됨. 
		- Web api = DOM, BOM, Canvas, XMLHttpRequest, fetch, SVG 등 
	- 서버사이드에서 실행되면, web api 는 지원되지 않음 
```


<br>

# 자바스크립트 특징

```bash 
- 웹 브라우저에서 동작하는 '유일' 한 언어
- 인터프리터 언어 
```


- 컴파일 언어 vs 인터프리터 언어 
``` bash
- 컴파일러 언어 
1. '컴파일' 과 '실행' 이 분리 


- 인터프리터 언어 
1. '컴파일' 과 '실행' 이 분리되지 않음 
2. 소스코드가 바이트 코드로 변환되면, 인터프리터 언어는 바이트 코드를 한줄 한줄 읽으면서 실행함
```
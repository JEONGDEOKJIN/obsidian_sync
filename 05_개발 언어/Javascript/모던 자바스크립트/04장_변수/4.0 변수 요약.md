
## 변수 메커니즘이 필요한 이유 

- 요약 
``` bash 
- 요약 
변수란, '값' 을 'CRUD' 하는 매커니즘

- 문제 상황
값을 저장하고, 가져올 때, 메모리 주소에만 기반해서 CRUD 를 하면, 너무 '비효율적'임. 
ex) 좋아요 숫자를 보여주고 싶어 -> 좋아요 데이터를 가져와야 해 -> 이런 상황에서, '0x123123' 주소를 입력하는 것 보다 'likeNum' 식별자를 입력하는 편이, 훨씬 효율적임. -> 이렇게 작동하게 하기 위해, 자연어를 입력하면, '심볼 테이블' 에 의해 변수가 메모리 주소로 변환되는 과정을, 자동적으로, 거치게 한다. 

즉, 값을 저장하고 싶으면, 그냥 하면 됨. (메모리 셀에 넣으면 됨. )
그런데, 값을 가져오고 싶을 때도 있고, 수정, 삭제 하고 싶을 때도 있음. 

근데 왜 꼭 가져와야 하고, 수정 해야 해? 
그게 데이터의 숙명임. (CRUD 가 되어야, 데이터는 항상 믿을 수 있는 자료가 됨)

그러면, 가져와야 한다는 걸 받아들였다면, 어떻게 가져올 건가 
메모리 주소를 적어서, 가져올 수 있음. 

문제는 매번 16진수를 적어서, 가져오는 건, 문제임. 
그래서, 이러한 매커니즘(방식) 을 고안함. 

- 변수 매커니즘 
1. 값은 메모리 셀에 저장되고, 메모리 셀에는 메모리 주소가 있음. (이 체계 자체를 변경하는건 아님) 
2. 메모리 주소는 고유한 16진수 인데, 더 쉽게 지정하게 하기 위해 인간의 언어로, 해당 메모리 주소를 딱 특정할 수 있게 함. 
3. 어떤 이름이 어떤 메모리 주소를 특정하고 있는지를 기록한게, 심볼 테이블임. 
4. 그 결과, 
	1) 인간은, 자신이 편한대로, 변수의 이름을 작성하고 ex) 값을 잘 설명하는 이름 등⭐  
	자동적으로, 2) 변수와 대응되는 메모리 주소를 확보하고 
	3) 메모리 주소에 바인딩된 메모리 셀을 확보하고 
	4)  메모리 주소와 변수를 '심볼 테이블'에 등록 하고 
	5) 저장하려는 값을 메모리 셀에 넣고, 저장한다. 
	6) 그 결과, '값을 CRUD 할 때의 효율성' 이 증가 될 수 있다. ⭐⭐⭐ 


- 값을 가져오는 매커니즘 비교 
	- 메모리 주소만 사용할 경우 
		1) 값을 가져오고 싶은 메모리 주소를 입력 -> 해당 메모리 주소에서 값을 가져온다. 
	- 변수 매커니즘을 사용할 경우	
		1) 값을 가져오고 싶은 식별자 이름을 입력 -> 심볼 테이블(식별자와 메모리 주소가 매핑된 테이블) 에서 메모리 주소를 가져오고 -> 해당 메모리 주소를 넘긴다. -> 해당 메모리 주소에서 값을 가져온다. 
	- 변수 매커니즘을 사용할 경우, 추가 처리가 필요하지만, 사용자 편의성은 증가된다. 


- 시사점은, 
	- 사실, 16진수 메모리 주소를 적으면서 써도 되는데, 좀 더 편하게 하기 위해, 이러한 방식을 만든거다. (이런 과정은 프로그래밍 언어 자체의 탄생과도 비슷한 것 같다.) 
	- 모든 값은 CRUD 의 숙명을 타고난다. 따라서, 잘 지켜줘야 함. 
	- '값' 을 중심으로, 컴퓨터 안에서 벌어지는 일을 이해하자. 값 자체가 어떻게 생기고, 어떻게 CRUD 해야 하는지. 이 과정에서, 더 편한건 뭔지. 

(출처 : 모던 자바스크립트 deep dive 36p)
```


<br>

- 필요성 
``` bash
- '2 + 10;' 연산 실행 결과값을 메모리에 저장한다. '메모리에 저장된 값'을 '재사용' 하기 위해서.

- '재사용' 하기 위해 '직접 메모리 주소를 제어' 할 경우 
	- '운영 체제' 같은 중요한 정보를 변경할 수 있는 위험 
	- 새롭게 프로그램이 시작 될 때 마다, '주소값이 변경' 되는 위험이 생김. 

- 따라서, '메모리 주소와 매핑된 변수 이름' 을 사용함으로써, 재사용이 가능하면서, 메모리 주소를 직접 컨트롤 할 때 발생하는 문제를 없앰. 
(출처 : 모던 자바스크립트 p35)
```


<br>

- 변수 매커니즘 활용 
``` bash
- '하나의 변수' 에는 '하나의 메모리 주소' 만 으로가므로 -> '하나의 값' 만 가능한가. 
	- 원칙적으로 변수는 하나의 값을 저장하기 위한 수단. 
	- 다만, '객체, 배열' 과 같은 자료구조를 사용하면, '값을 그룹화' 해서, 하나의 값처럼 사용할 수 있다. 
(출처 : 모던 자바스크립트 p37)
```

<br>

## 변수란? 식별자 란? 
``` bash 
- '변수 이름' 은 '식별자(identifier)' 의 한 종류다.

- 식별자란, '메모리 공간'에서, '하나의 고유한 값을 식별' 할 수 있게 하는 '고유한 이름' 이다. 
- 식별자는, '메모리 주소'와 '매핑 관계' 를 갖는다. (아, 이게 name binding 을 하는 거구나.)

- 식별자의 종류 
	- 함수, 클래스, 변수 등이 모두 식별자다. 
	- 메모리 안에서, 하나의 고유한 값을 구분하기 위해 사용되면, 식별자 다. 
	- 그러면, 함수도 메모리 안에 값을 담고 있고, 클래스도 값을 담게 된다는 말 이다. 

- 변수는 '선언 -> 할당 -> 재할당' 의 과정을 거친다. 
```


<br>

## 변수 선언 
- 변수 선언 이란 
``` bash 
- 변수 선언을 바라보는 관점 
	- 변수의 '생명주기⭐' 관점에서 '변수 선언' 을 바라볼 필요가 있음. 
	- 메모리 공간에서 생겨나고, 사라지는 관점에서, 이해할 필요가 있음. 

- 변수 선언의 의의
	- 변수 선언 이란, '변수를 생성' 하여 '값이 들어갈 ⭐준비⭐' 를 하는 것. 
	- '변수 선언이 실행된다.' 이라는 것은, '선언문이 한번씩 실행⭐' 된다는 것을 의미 (출처 : 모던 자바스크립트 p42)
	
- 값이 들어갈 수 있게, '무엇을, 어떻게 준비' 하는가?  ⭐⭐⭐⭐⭐ 
	- '선언문이 한번씩 실행' 된다. ⭐⭐⭐ 
	- 선언문이 실행되면,
		1) 값을 저장하기 위한 '메모리 공간' 을 확보('allocate'), 
		2) 그 메모리 공간의 주소와 변수 이름을 '연결(name binding)' 해서 
		3) '값을 저장할 수 있게 준비!' 하는 것 ⭐⭐⭐ (출처 : 모던 자바스크립트 p39)
		4) 더 나아가, '초기화' 까지 (출처 : 모던 자바스크립트 p41) 진행된다. 
		CF. (변수 키워드에 따라서, 초기화 시점이 달라짐. var 는 선언과 초기화가 동시에! let, const 는 선언과 초기화가 분리! 되어 진행된다.)
		5) [js 엔진 관점] 선언문이 실행된 스코프인, 렉시컬 환경 안에 있는 환경 레코드에 해당 식별자와 (존재한다면) 초기값을 등록한다. 
		👉 여기까지 오면, 값이 들어올 수 있는 준비가 된 것 이다. 


CF. 변수를 생명주기 관점에서 바라볼 때 느껴지는 것 ⭐⭐ 
	- 변수를 만들고, 가져오고 하는 것이, 결국, 값(데이터) 를 CRUD 하는 것으로 느껴짐. '값' 을 중심에 놓고 설명하면, 깔끔하다는 느낌  
		- 즉, '특정 용어' 는 '특정 매커니즘(방식)' 에 불과함. ⭐⭐⭐⭐⭐  
		- 예시 
			- '내가 원하는 값을, 정말로 저장' 하려면 '선언' 이라고 불리는 '준비 단계' 를 거쳐야 함. 
			- '이 값이, 실제로 저장되는 순간' 은, '할당' 이라고 불리는 '저장 단계' 를 거쳐야 함.

	- 파편화된 지식이 '생명주기' 라는 상위 개념 아래에서 설명된다. -> 현상을 하나의 개념으로 파악하면 되기에, 조금 더 수월하게 느껴진다. 


CF. 이 부분은 내용 체크 📛📛📛 
- 선언을 할 때는, var, let, const 키워드를 사용한다. -> 어떤 키워드를 사용하느냐에 따라, '스코프' 가 결정된다. (블록 레벨 스코프, 함수 레벨 스코프)
- '스코프' 는, '참조할 수 있는 유효범위' 임. 
- 이때, 스코프를 추상적으로 생각할 것 이 아니라, '스코프의 실체'는  '렉시컬 환경' 으로 생각하면 됨. 
- 참조 할 때, 렉시컬 환경에서, 환경 레코드에 값이 있는지 보고, 없으면 스코프 체인을 따라서 상위 스코프(상위 렉시컬 환경) 의 값을 참조하게 되는 거지. 
- 그러면, 함수레벨 스코프라면? 1) 함수 블록 안에서, 하나의 렉시컬 환경만 갖는다. -> 따라서, 함수 안에 if , for 등의 블록 안에, 같은 변수 이름이 있어도, 동일한 변수로 설정된다. -> 그래서, 재할당, 이 된다. 
- 블록레벨 스코프라면? 1) 블록 마다, 개별적인 렉시컬 환경을 갖는다. -> 따라서, 블록마다 동일한 변수를 갖더라도, 다른 저장 메모리에 저장되는 다른 변수가 된다. 
```

![](https://i.imgur.com/JTJ2b4n.png)


- 변수 선언 단계 
``` bash 
1. 선언 단계
	- '변수 이름' 과 '메모리 주소' 를 연결 (name binding)

2. 초기화 
	- 메모리 공간에 'undefined' 값을 할당
	- 'undefined' 는 '원시 타입의 값' 이다. 

(출처 : 모던 자바스크립트 p41)
```

- 선언 이후 벌어지는 일 
``` bash 
- 변수 이름이 '실행 컨텍스트 > 렉시컬 환경 > 환경 레코드'에 등록된다. 
- 실행 컨텍스트에 의해 '변수가 관리' 된다. 
- js 엔진 평가 단계에서, 선언문 호이스팅 되어 -> 선언문만 1회 실행되고 -> 등록된다. 
```


<br>

## 변수 선언의 실행 시점과 호이스팅 
``` bash 
- '변수 선언이 실행된다.' 이라는 것은, '선언문이 한번씩 실행' 된다는 것을 의미 (출처 : 모던 자바스크립트 p42)
	- '선언문이 한번씩 실행' 되고, 그에 따라서, 1) 메모리 allocate 2) 변수와 메모리 주소 name binding 3) 값 초기화 ⭐⭐⭐⭐⭐ 

- 이러한 '변수 선언의 실행' 은 언제이루어져? 
	- 런타임 이전! ⭐⭐⭐⭐⭐
	- js 엔진의 실행(런타임) 이전 
	- js 엔진의 평가 단계 (AST 만드는 파싱 단계)

- 그러면, 이 시점이 왜 중요해? 	 
	- 변수 선언의 실행이 런타임 이전에 작동하기 때문에, 호이스팅이 발생하게 된다. 
	- 선언 이라 하면, 통념적으로, 변수만 할당하는 걸 의미한다고 생각하게 되는데, 그 안에 초기화가 있고, 그로 인해, 작동 되어선 안 되는 구문이 작동되게 되기 때문에 (호이스팅으로 인해) ⭐⭐⭐ 
	- 평가 단계에서, 모든 선언문은, 한번씩, 먼저, 실행된다 -> 따라서, 모든 선언문이 '코드의 상단'으로 끌어올려지는 '호이스팅'이 발생 ⭐⭐⭐⭐⭐ 
(모던 자바스크립트 p43)

- '소스코드가 실행' 되는 시점 
	- 인터프리터가 바이트코드를 실행하는 시점에 실행된다. 
	- 한줄 한줄 씩 순차적으로 실행된다. 
	- 이때, '대입 연산자' 등이 실행된다. 
(모던 자바스크립트 p43)

- 호이스팅 이란 
	- 모든 선언문이, 소스 코드의 상단으로 옮진 것 처럼 동작하는, JS 고유의 특징
	- '레퍼런스 에러(실행컨텍스트에 등록되지 않은 식별자를 참조하려 할 때 발생하는 에러)' 가 발생할 것 같은 상황에서 undefined 가 찍히는 이유
```


<br>

## 값의 할당 
``` bash 
- 실행 시점 
	- 할당은 '대입 연산자' 를 통해서 이루어 짐 -> '평가 이후' , '실행 단계' 에서 이루어짐 

- 단축 표현
	- 변수 선언과 할당을 '한 줄' 로 단축 표현해도 -> JS 엔진은 '선언과 할당' 을 '2개의 문' 으로 나누어 '각각' 실행한다. ⭐⭐
	- 그 이유는 '평가와 실행' 이 구분되어 있고, '평가 과정에서 모든 선언문을 1회 실행' 하기 때문.
```


<br>

## 값의 재할당 
``` BASH
- '해당 변수' 에 기존값이 아니라, '새로운 값' 을 할당하는 경우 -> '새로운 메모리 주소' 를 확보해서 저장한다. -> 사용하지 않는 메모리는 '가비지 컬렉터' 에 의해 제거

- var, let, const 
	- var : 재할당 허용. 덮어 쓰기 가능. 다만, 덮어 쓸 때, 메모리 주소는 새로 생성되어 저장하게 됨. 
	- let : 재할당 가능! 덮어 쓰기 가능. 다만, 덮어쓴다는 건, 새로운 메모리 주소에, 동일한 변수 이름으로 저장한다는 의미. 실제로 동일한 메모리 주소에 덮어 쓰는 건 아님 
	- const : 재할당 허용하지 않음 -> so, 그 변수 이름은 딱 한번만 쓸 수 있음. ⭐⭐⭐ 
```

![](https://i.imgur.com/4jOkFmS.png)





---

- 출처 : [[240108_150010_변수]]
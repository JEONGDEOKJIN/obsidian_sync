
## '동기 처리와 비동기 처리' 에 대한 일반론

``` bash 
- 동기 처리 
	- 처리 방식
		- '현재 실행 중인 태스크' 가 '종료되지 않은 상황에서(진행중인 상황)'에서 -> '다음에 실행된 태스크' 가 '대기' 하게 해서 처리하는 방식
	- 장점
		- '소스 코드' 의 '실행 순서' 가 보장된다. (즉, 소스코드의 실행순서와 실제 실행순서가 동일하다. ) 
	- 단점
		- '블로킹'(실행될 태스크들이 대기) 현상 발생

- 비동기 처리 
	- 처리 방식
		- '현재 실행 중인 태크스'가 '종료되지 않은 상황'에서 -> '그 다음 태스크' 를 '곧바로 실행' 한다. 
	- 장점
		- '블로킹'(다음 태스크가 대기) 현상이 발생하지 않는다. 
	- 단점
		- '소스 코드 상의 기재 순서'와 '실제 실행 순서' 가 달라질 수 있다. ⭐⭐⭐  
		- 실행순서가 보장되지 않는다. 
		- 구체적으로 무엇의 실행 순서가 달라지는가? : ⭐⭐ Task queue 안으로 들어가는 콜백함수, 이벤트 함수의 실행 순서가 부정확 ⭐⭐
			- ex) setTimeout 에서 0초를 delay 하더라도
				- 1) Web API 를 제공하는 브라우저 자체에서 0~4ms 미만은, 대기 시간을 4ms 로 강제하여 -> 실제로 0ms 로 설정했음에도, delay 시간은 4ms 가 되고 
				- 2) [실행 순서 관점] 실행 순서도, 1) 'JS 엔진의 콜 스택이 다 비워진 후' 2) Task Queue 에 태스크가 있으면 3) FIFO(First in First out) 으로 실행되기 때문에, -> 소스코드 상의 기재 순서와, 실제 실행 순서가 일치 하지 않는다. 즉, 소스 코드 상 첫 번째 실행이어도, TASK QUEUE 에서 대기하고 있다가, 전역 실행 컨텍스트 까지 모두 POP 되고 난 다음 실행된다. 

- 비동기 처리 이슈의 핵심 
	- 'Task Queue에 대기하고 있는 함수' 의 실행순서, 처리결과값을 어떻게 컨트롤 할 것 인가. 

👉 그러면, 웹 어플리케이션에서 주목해야 하는, 브라우저와 자바스크립트 엔진은 어떻게 처리되고 있을까? 
👉 중요한 건, "장점과 단점을, 텍스트로 암기하고 있는 것을 넘어서, 프로그래밍을 할 때, 단점을 어떻게 보완해 나갈 것 인가! 를 고민하고, 검색하고, 실행해 나가는 것이다." ⭐⭐⭐ 

```


<br>


## 브라우저와 자바스크립트 엔진의 처리 방식은? 
``` bash 
- 브라우저의 구성 요소
	- '브라우저' 안에는 '자바스크립트 엔진', '렌더링 엔진', 'Web API' 등이 있다. 


- 브라우저의 특징 
	- '브라우저' 는 '멀티 스레드' 로 동작한다. 
		- 따라서, '자바스크립트 엔진' 이 동작하면서, 'Web API' 가 동작할 수 있다. (그래서, 'setTimeout 실행시, 타이머 함수(web api 제공)가 동작하면서, js 엔진이 그 다음 소스코드를 평가, 실행' 하는 비동기 처리가 가능한 것.)
		- 혹은, '자바스크립트 엔진' 이 동작하면서 '렌더링 엔진' 이 동작할 수 있다. (그래서, 'js 엔진이 서버에서 fetch 해오면서, 렌더링 엔진이 화면을 그리는' 비동기 처리가 가능한 것.  )
		- 그러므로, '브라우저 안에서 벌어지는 일' 은 '브라우저 하위 요소간의 협업' 을 통해서 나오는 것임을 염두해야 함. 

- JS 엔진의 특징
	- 자바스크립트 엔진은 '하나의 콜 스택' 이 있다. 
		- 이는, JS 엔진은 '싱글 스레드' 방식으로 동작한다. 는 의미다. 
		- 따라서, '한번에 하나의 태스크' 만 처리할 수 있고, '동시에, 2개 이상의 태스크는 처리 불가' 하다. 
		- 따라서, '실행 태스크 이외에 다른 태스크' 는 '기다려야 한다.' (블로킹 현상, 작업 중단 현상)
		- 따라서, ⭐'콜스택' 안에서, '최상단 실행 컨텍스트'가 실행중이면, 그 밑에 있는 실행컨텍스트들은 '대기' 해야한다. 

	- JS 엔진이 싱글 스레드 이므로, 모든 JS 소스 코드는 '동기처리가 되어야 할 것 같다.' 
	
	- 하지만, 실제로, '브라우저' 안에서 동작되는 것을 보면, '동시에 많은 태스트가 처리(비동기 처리)' 된다. ⭐⭐⭐ 
		- ex) 'HTTP 요청' 을 통해 -> 서버에서 데이터를 가져오면서 렌더링 한다. (출처 : 모던 자바스크립트 p812)
		- ex) '이벤트 처리(이벤트 핸들링)' 를 할 때, -> '애니메이션 효과' 가 나오면서 처리 (출처 : 모던 자바스크립트 p812)



- 자바스크립트 '동시성(concurrency)' 을 가능하게 하는 것은?  ⭐⭐⭐⭐⭐ 

👉 대체, 무엇 때문에, js 소스코드를 평가-실행하는 js엔진은 '싱글스레드' 인데, '비동기 효과'가 나는 걸까? ⭐⭐⭐⭐⭐
	
	1) 비동기 처리가 필요한 코드의 경우 '제어권이 브라우저로 이동' (js 엔진이 하는 일)
		- '타이머 함수인 setTimeout, setInterval, HTTP 요청, 이벤트 핸들러' 는 '비동기 함수' (비동기 처리가 필요한 코드가 내부에 존재) 가 난다. 
		- 왜냐면, 'setTimeout, setInterval, HTTP 요청, 이벤트 핸들러' 는 'web api' 에서 제공하는 기능이므로 
		- 따라서, js 엔진은 '비동기 함수의 실행컨텍스트를 생성' -> '비동기 처리가 필요한 코드 ex) 타이머 함수' 의 실행 컨텍스트도 생성! ->   '비동기 처리가 필요한 코드에 대한 제어권'을 'Web API' 에게 넘기고 브라우저가 처리 한다. -> 그리고, 'JS 엔진'은 '비동기 함수 실행컨텍스트를 pop' 시키고, 싱글 스레드로써, 해당 함수 코드를 평가~실행 한다.  
		
	2) 브라우저는 '해당 코드를 Task queue 로 이동시킬지 체크 ex) 일정한 시간이 흘렀는지 👉 Task Queue 이동, onload 이벤트 발생됐는지 체크 👉 콜스택 empty 될 때 까지 대기  👉 FIFO 순서로, 콜스택 이동' 시킨다.  
		- JS 엔진과 브라우저는 각자 할 일을 하고 있음 -> '협업' 이 되려면, web api 가 처리한 일을 js 엔진에, 잘 합칠 수 있어야 함. 이 일을 이벤트 루프가 한다. 
		- Web API 가 자신의 할일을 하고 (해당 함수를 task queue 에 넣고 대기) -> 이벤트 루프가 'Web API 와 JS 엔진 사이를 오가면서, 해당 함수가 다시 JS 엔진 콜스택에 들어갈 타이밍' 을 본다.
		- 그리고 1) JS 엔진의 콜 스택이 비어있고 2) Task Queue 안에 태스크가 있으면 3) FIFO 순서로 태스크를 콜스택으로 호출해서 실행시킨다. 
		- 그 결과, I/O 태스크 이후에 있는 태스크는 대기 시간 없이, '비동기 처럼 처리' 된다. 
		- 이때, Task Queue 로 이동하고, Event loop 에 의해 옮겨지는 함수는, js 엔진의 콜 스택이 전부 비워져야 실행이 되므로, 멀티 스레드에서의 비동기처리와 비교했을 때, 실행되는 시점이 다를 수 있다. (즉, js 엔진의 스택이 전부 비워질 때 까지, 기다려야하는 추가 비용이 발생)


- 비동기 처리의 전통적인 방식 
	- 프로미스


CF. 블로킹(blocking) = 작업 중단
CF. '타이머 함수인 setTimeout, setInterval', 'HTTP 요청', '이벤트 핸들러' 는 '비동기 처리 방식' 으로 동작함! ⭐⭐⭐⭐⭐(이제, 이걸 잘 다뤄야만 한다. ⭐⭐⭐) (출처 : 모던 자바스크립트 p812)
```
- 추가 학습 
	- 프로미스(모던 자바스크립트 45장)✅ [[5. githubSync_gitBook/05_개발 언어/Javascript/모던 자바스크립트/45장_프로미스/45.0 프로미스 요약]]

<br>

## 웹 애플리케이션에서, '비동기 처리' 를 가능하게 하는 것은?
``` bash
- '타이머 함수인 setTimeout, setInterval', 'HTTP 요청', '이벤트 핸들러' 는 '비동기 처리 방식' 으로 동작함! ⭐⭐⭐⭐⭐(이제, 이걸 잘 다뤄야만 한다. ⭐⭐⭐) (출처 : 모던 자바스크립트 p812)

- 이것들의 공통점은, 해당 함수는,  js 엔진 안에, 내장 되어 있지 않다.⭐⭐⭐⭐⭐ 
	- ex) 타이머 함수는 setTimeout, setInterval (web api) 에 의해 제공된다는 것. 
	- ex) HTTP 요청은 fetch(web api) 에 의해 제공되고 
	- ex) 이벤트 핸들러는 DOM(web api) 에 의해 제공됨. 

- js 엔진 내부에 내장 되어 있지 않으므로 -> 제어권을, '해당 함수를 제어할 수 있는 요소 ex) web api'에 넘기고 -> js 엔진은 다시 소스코드를 평가-실행 한다. -> 그리고 js 엔진은 동기처리 흐름 안에서, '이벤트 루프' 의 도움을 받아, 다른 요소가 제어한 함수를 실행한다.

- 그 결과, 비동기 효과가 난다.
```


<br>

## setTimeout 이 작동하는 과정 

``` js 
function foo( ) {
	console.log("foo");
}

function bar( ) { 
	console.log("bar");	
}

// 타이머 함수 setTimeout 은 일정시간이 경과한 이후에 콜백함수 foo 를 호출한다. 
// 타이머 함수 setTimeout 은 bar 함수를 블로킹 하지 않는다. 
setTimeout(foo, 3 * 1000);
bar( );


- 출처 : 모던 자바스크립트 p814
```


``` js 
// 1. 전역 코드 평가
	// - 참고 : [[23.0 요약#4) foo 함수 코드 평가]] 옵시디언 필기 참고

// 2. 전역 코드 실행 
	// 2.1 제어권이 setTimeout 함수 내부로 이동 ( 출처 : 모던 자바스크립트 p814) 
		// 2.1.1  2개의 실행 컨텍스트 생성 : 1) setTimeout 자체의 실행 컨텍스트 2) web api 를 호스트로 하는 '⭐타이머 함수⭐'의 실행 컨텍스트 
		// 2.1.2  setTimeout 실행 컨텍스트 call stack 으로 이동 -> 실행 
		// 2.1.3   JS 엔진은 'web api 를 호스트로 하는 타이머 함수' 를 내장하고 있지 않으므로 -> 타이머 함수 실행 컨텍스트 제어권을 '브라우저' 에게 넘김 ⭐⭐⭐⭐⭐ 
		// 👉 그 이후는 '브라우저가 멀티 스레드 이므로, 병행 처리' 됨! ⭐⭐⭐ 
			//  1) JS 엔진은 setTimeout 함수 를 스택에서 pop 하고 -> 다음 줄로 이동 
			//  2) ⭐동시에(병행 처리)⭐,
				// a) 브라우저가⭐ 호출 스케줄링(타이머 함수 제어권이 있는 web api 는, 시간 대기(3 * 1000) 한다.
				// b) 대기 시간 만료하면, 브라우저가⭐콜백 함수⭐를 task queue 에 등록 한다. 
			// 3)  js 엔진의 콜스택이 비어 있으면, 이벤트 루프가 해당 '콜백 함수를 js 엔진 콜스택으로 이동~! 

	// 2.2 [JS 엔진] bar 함수 실행 컨텍스트 생성 -> 콜스택 push -> 실행 -> pop 
	// 2.3 [JS 엔진] 전역 실행 컨텍스트 생성 -> 콜스택에 push -> 실행 -> pop -> 콜스택 비어있게 됨 ⭐⭐ 
	// 2.4 [브라우저의 이벤트 루프] task queue 에 대기하고 있는 '⭐콜백함수⭐' 를 FIFO 순서로, CALL STACK 에 PUSH -> 콜백함수의 실행 컨텍스트 생성 되어 PUSH 되므로 실행 -> 실행 완료 후 POP -> 다시 CALL STACK 이 비어있게 됨 -> 종료


✅ task queue 에는 1) 비동기 함수의 콜백함수 2) 이벤트 핸들러, 가 일시 보관 되는 영역 (출처 : 모던 자바스크립트 p814)
👉 결국, '자바스크립트 엔진' 과 '브라우저' 가 '협력' 하여, '비동기 함수' 인 'setTimeout' 을 '비동기 처리' 한다. 
👉 다른 비동기 처리들도, 익혀보자. 
```








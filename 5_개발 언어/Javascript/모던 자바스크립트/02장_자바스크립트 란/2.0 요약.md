

# 자바 스크립트의 탄생
``` bash
웹 페이지의 '보조적인 기능' 을 수행하기 위해서, '경량' 프로그래밍 언어로 도입
```


<br>

# 자바스크립트의 표준화

``` bash
- 마이크로소프트는 자바스크립트의 '파생 버전' 인 'jscript' 를 출시 -> '자바스크립트와 jscript 간 호환이 벽하지 않는' 문제가 발생 -> '크로스 브라우징 이슈' 발생

- '모든 브라우저에서 정상 작동' 하게 하기 위해 -> 넷스케이프 커뮤니케이션즈에서, 'ECMA(비영리 표준화 기구)' 에 자바스크립트 표준화 요청 -> 이후 ECMA 가 표준화 버전 배포  
```


<br>

# 자바스크립트 성장 역사

## 1) 웹페이지 보조 기능 및 기초 렌더링

``` bash 
- 초창기 자바스크립트는 웹페이지의 '보조적 기능' 을 수행함
- 대부분의 로직 = 웹 서버 
- 브라우저는 HTML, CSS 렌더링 역할
```
- 38장 브라우저 렌더링 참고
	- [[5. githubSync_gitBook/5_개발 언어/Javascript/모던 자바스크립트/38장_브라우저의 렌더링 과정/38.0 브라우저 렌더링 과정 요약]]


<br>


## 2) ajax
``` bash
- ajax 의 핵심 
	- 서버와 브라우저가 '비동기' 방식으로 통신할 수 있는 기능
	- Web API 가 제공하는 'XMLHttpResquest' 객체의 프로퍼티 및 메서드를 이용

- ajax 이전 
	- '변화된 부분 렌더링(ex. 좋아요 버튼만 업데이트)' 할 때 -> '전체 페이지' 를 서버에 '동기적으로' 요청하고, -> 응답 받은 html 기반으로, '처음부터 새롭게 그림' -> 깜빡이는 현상 발생 

- ajax 이후 
	- 'DOM 트리에서, 변화된 부분을 업데이트' 할 때
		1) 변화된 부분의 데이터만, 비동기적으로 요청
		2) 필요한 부분만 렌더링

- 효과 
	- '웹' 브라우저에서 '데스크톱에 준하는' 성능과 부드러운 화면 전환 효과 ex) 구글 맵스 
	- 웹이 데스크톱의 효과를 따라가기 시작
```

- 참고 : 모던 자바스크립트 ajax 파트 [[5. githubSync_gitBook/5_개발 언어/Javascript/모던 자바스크립트/43장_ajax/43.0 ajax 요약]]



<br>

## 3) jQuery
``` bash
- jQuery 가 해결한 문제
	- 'DOM 제어' 를 쉽게 해줌 -> 그에 따라, '크로스 브라우징 이슈' 어느 정도 해결
```


<br>

## 4) V8 자바스크립트 엔진
``` bash
- V8 가 해결한 문제 
	- 웹 어플리케이션의 수요 증가 -> 빠르게 동작하는 JS 엔진이 필요 -> V8 등장으로 어느 정도 해결

- 효과 
	- 데스크톱 어플리케이션 과 유사한 UX 경험
```


<br>

## 5) Node.js
``` bash
- node.js 가 해결한 것 
	- v8 엔진으로 빌드된 js 런타임 환경 -> 브라우저를 벗어나 서버 사이드 어플리케이션에 js 가 사용될 수 있게 됨. 
```
추가 학습 : [[5. githubSync_gitBook/5_개발 언어/Javascript/모던 자바스크립트/02장_자바스크립트 란/node.js 특징]]


<br>


## 6) SPA 프레임워크
``` bash
- SPA 프레임 워크가 해결한 문제 
	- '페이지 부분 렌더링(업데이트)' 시, JS로 'DOM을 직접 조작'의 비효율성 발생 (이전, ajax 시절)
		1) 불필요한 reflow 및 repaint 가 발생 ex) 특정 노드를 취득 및 변경 하면 -> 해당 노드의 자식 노드 까지 변경 -> 자식 노드의 reflow, repaint 라는 불필요한 리소스가 소모됨.
		2) 이것을 최적화 하기 위해 코드가 복잡해짐 ex) 수정되어야 하는 DOM 노드가 100개 인 경우 -> innerHTML 을 100번 사용해서, 100번 DOM 수정 vs '1번의 DOM 수정' 으로 업데이트 할 수도 있음. -> 그런데, 1번의 DOM 수정을 하기 위해서, 고려해야 하는 '코드의 복잡성' 이 증가함 ex) innerHTML 예시

	- 이 문제를 해결하기 위해, Virtual DOM 을 사용한 렌더링 프로세스를 개발  
		1) 게임 엔진의 원리(보여줄 화면을, 미리, 만들어놓는다.) 를 응용하여
		2) 리액트 상의 각각의 컴포넌트를 -> React Element 로 만들고 -> 각각의 React Element 를 모아서 Virtual DOM 으로 만들고 -> 최소화된 DOM 조작으로, 실제 DOM을 업데이트 하고 -> paint 한다. 

	- 만약, '재조정' 을 해야 하는 경우 
		1) 각각의 컴포넌트를 -> React Element 로 만들고 -> 각 React Element 를 모아서 Virtual DOM 으로 만든다. 
		2) 현재 VDOM 과 기존 VDOM 의 차이점을 모두 파악해서 -> ⭐'하나'⭐ 로 모은다 -> 최소한의 DOM 조작(하나로 모았기 때문에 가능) 으로 실제 DOM 을 업데이트 하고 -> paint 한다. (이게 렌더링 프로세스가 반영된 거지)

	- 시사점 
		1) '업데이트가 필요한 노드' 에 대해서만 '렌더링' 이 일어나서 -> 리소스 효율화
		2) '최소한의 DOM 업데이트' 가 이루어짐 
		3) '대부분의 업데이트' 가 부드럽게 이루어짐 


- SPA 프레임 워크가 해결한 것 
	- 개발 규모와 복잡도 상승 문제 발생 
	- CBD 방법론 기반 -> SPA 프레임워크 및 라이브러리 등장
```

- 보완할 점 : Virtual DOM 정리본 보면서, 내용 정확성, 보완
- 실제로 해볼 것 : story book 과 CBD 방법론을 함께 사용해서 개발 진행해보기


<br>


# 자바스크립트와 ECMA script
``` bash
- 자바스크립트는 
	- 클라이언트 사이드 환경에서 실행되는 경우 'core 인 ECMA' 와 '클라이언트 사이드 web api(브라우저가 지원)' 로 구성됨. 
		- Web api = DOM, BOM, Canvas, XMLHttpRequest, fetch, SVG 등 
	- 서버사이드에서 실행되면, web api 는 지원되지 않음 
```


<br>

# 자바스크립트 특징

```bash 
- 웹 브라우저에서 동작하는 '유일' 한 언어
- 인터프리터 언어 
```


- 컴파일 언어 vs 인터프리터 언어 
``` bash
- 컴파일러 언어 
1. '컴파일' 과 '실행' 이 분리 


- 인터프리터 언어 
1. '컴파일' 과 '실행' 이 분리되지 않음 
2. 소스코드가 바이트 코드로 변환되면, 인터프리터 언어는 바이트 코드를 한줄 한줄 읽으면서 실행함
```